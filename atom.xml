<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>黑月的BLooooog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://fenglai0802.github.io/"/>
  <updated>2017-03-01T11:56:51.000Z</updated>
  <id>https://fenglai0802.github.io/</id>
  
  <author>
    <name>黑月</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Web Audo API advance</title>
    <link href="https://fenglai0802.github.io/2017/03/01/Web-Audo-API-advance/"/>
    <id>https://fenglai0802.github.io/2017/03/01/Web-Audo-API-advance/</id>
    <published>2017-03-01T11:36:03.000Z</published>
    <updated>2017-03-01T11:56:51.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Web-Audio-API-Advance"><a href="#Web-Audio-API-Advance" class="headerlink" title="Web Audio API Advance"></a>Web Audio API Advance</h2><p>一个简单的、典型的web audio工作流是这样的：</p>
<ol>
<li>创建音频环境对象（AudioContext）。</li>
<li>在音频环境对象AudioContext中，创建音源。例如<code>&lt;audio&gt;</code>，振荡器（oscillator），源。</li>
<li>创建效果节点（effectNode），例如分析、增益、混响、双二阶滤波器、平移、压缩等。</li>
<li>选择最终的音源目的地，例如你的系统扬声器。</li>
<li>连接源到效果节点，以及效果节点到输出终端。</li>
</ol>
<p><img src="./images/web_audio_api/1.png" alt=""></p>
<p>简单来说，<code>Web Audio API</code>提供了一个简单强大的机制来实现控制web应用程序的音频内容，但是<code>Web Audio API</code>并不会取代<code>&lt;audio&gt;</code>，而可以把它看做是<code>&lt;audio&gt;</code>的补充，就好像<code>&lt;img&gt;</code>和<code>&lt;canvas&gt;</code>的共存关系。你用来实现音频的方式取决于你的需求的复杂程度，如果只是简单的音轨播放，那么<code>&lt;audio&gt;</code>足够了。</p>
<p>这里首先来明确两个概念。</p>
<h3 id="1-AudioContext-–-音频环境对象"><a href="#1-AudioContext-–-音频环境对象" class="headerlink" title="1. AudioContext – 音频环境对象"></a>1. AudioContext – 音频环境对象</h3><p>W3C描述如下:</p>
<blockquote>
<p>This interface represents a set of AudioNode objects and their connections. It allows for arbitrary routing of signals to the AudioDestinationNode (what the user ultimately hears). Nodes are created from the context and are then connected together. In most use cases, only a single AudioContext is used per document.</p>
</blockquote>
<p>大致意思是这个接口是音频节点和节点之间连接关系的集合。他允许信号经过任意的路由连接到目的节点（音频播放设备节点）上。节点都是通过音频环境（AudioContext）创建的，然后连接在一起。在大多数情况下，一个文档只需要一个音频环境。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// 1.创建音频环境对象AudioContext；</span></div><div class="line"><span class="keyword">var</span> audioCtx = <span class="keyword">new</span> AudioContext();</div><div class="line"></div><div class="line"><span class="comment">// 2.创建音源节点</span></div><div class="line"><span class="keyword">var</span> sourceNode = audioCtx.createBufferSource();</div><div class="line"></div><div class="line"><span class="comment">// 3.创建效果节点</span></div><div class="line"><span class="comment">// 创建分析节点</span></div><div class="line"><span class="keyword">var</span> analyser = audioCtx.createAnalyser();</div><div class="line"><span class="comment">// 创建低阶滤波节点</span></div><div class="line"><span class="keyword">var</span> biquadFilter = audioCtx.createBiquadFilter();</div><div class="line"><span class="comment">// 创建增益节点</span></div><div class="line"><span class="keyword">var</span> gainNode = audioCtx.createGain();</div></pre></td></tr></table></figure>
<p>可以看出AudioContext相当于一个容器，各类音频节点，及节点间的连接方式都需要AudioContext的实例对象来创建。</p>
<h3 id="2-AudioNode-–-音频节点"><a href="#2-AudioNode-–-音频节点" class="headerlink" title="2. AudioNode – 音频节点"></a>2. AudioNode – 音频节点</h3><p>W3C中描述如下:</p>
<blockquote>
<p>AudioNodes are the building blocks of an AudioContext. This interface represents audio sources, the audio destination, and intermediate processing modules.</p>
</blockquote>
<p>音频节点是一个音频环境的基础模块。这些节点可以是音频源节点，音频播放设备节点，也可以是中间处理模块。</p>
<h3 id="3-Demo构建流程"><a href="#3-Demo构建流程" class="headerlink" title="3. Demo构建流程"></a>3. Demo构建流程</h3><p>先来看一个简单的音频模型，音频直接连接到播放设备节点播放。</p>
<p><img src="./images/web_audio_api/2.png" alt=""></p>
<p>再来看一套专业的音效合成处理图：</p>
<p><img src="./images/web_audio_api/3.png" alt=""></p>
<p>是不是很厉害，好，那么接下来我们讲点简单的……</p>
<h4 id="3-1-构建AudioContext对象"><a href="#3-1-构建AudioContext对象" class="headerlink" title="3.1 构建AudioContext对象"></a>3.1 构建AudioContext对象</h4><p>首先，需要构建一个AudioContext实例，来创建一个音频环境容器。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 1. 一个文档可以存在多个实例，但是没有必要，通常只需要一个。</span></div><div class="line"><span class="comment">// 2. 对于webkit/blink内核的浏览器需要加webkit前缀。</span></div><div class="line"><span class="comment">// 3. 在Safari浏览器中，如果不加window对象，会无效。</span></div><div class="line"><span class="comment">// 所以构建音频环境对象如下：</span></div><div class="line"><span class="keyword">var</span> audioCtx = <span class="keyword">new</span> (<span class="built_in">window</span>.AudioContext || <span class="built_in">window</span>.webkitAudioContext)();</div></pre></td></tr></table></figure>
<h4 id="3-2-创建音源AudioSource"><a href="#3-2-创建音源AudioSource" class="headerlink" title="3.2 创建音源AudioSource"></a>3.2 创建音源AudioSource</h4><p>现在有了环境的实例对象，前面也提到这个对象非常有用，接下来就是用这个实例整一个音源。音源可以用以下几种方式创建/获取：</p>
<ul>
<li>从PCM（Pulse Code Modulation，脉冲编码调制）数据构建：这个PCM数据是啥玩意，怎么来？简单的说：首先可以通过XMLHttpRequest获取被支持的音频格式的文件（比如x.mp3），然后利用AudioContext对象中的方法对文件进行解码后获得的数据。下文中提到的自产<a href="https://fenglai0802.github.io/demo/web_audio_api/simple.html">demo</a> ，就是利用这种方式获取音源的。AudioContext提供了解密被支持的音频格式的多种方法： <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/AudioContext/createBuffer" target="_blank" rel="external">AudioContext.createBuffer()</a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/AudioContext/createBufferSource" target="_blank" rel="external">AudioContext.createBufferSource()</a>, 以及 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/AudioContext/decodeAudioData" target="_blank" rel="external">AudioContext.decodeAudioData()</a>.</li>
<li>利用AudioContext对象直接生产音频节点，比如振荡器oscillator。具体API：<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/AudioContext/createOscillator" target="_blank" rel="external">AudioContext.createOscillator() </a></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> oscillator = audioCtx.createOscillator();</div></pre></td></tr></table></figure>
<ul>
<li>来自HTML音频元素，如我们熟悉的<code>&lt;video&gt;</code>或者<code>&lt;audio&gt;</code>.具体API: <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/AudioContext/createMediaElementSource" target="_blank" rel="external"> AudioContext.createMediaElementSource()</a></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> source = audioCtx.createMediaElementSource(myMediaElement);</div></pre></td></tr></table></figure>
<ul>
<li>直接来自于WebRTC，MediaStream。如摄像头、麦克风。具体API: <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/AudioContext/createMediaStreamSource" target="_blank" rel="external">AudioContext.createMediaStreamSource()</a>。这种方式可以看下MDN提供的<a href="https://mdn.github.io/voice-change-o-matic/" target="_blank" rel="external">Demo：the Voice-change-O-matic live</a>及<a href="https://github.com/mdn/voice-change-o-matic" target="_blank" rel="external">Demo源码</a></li>
</ul>
<h4 id="3-3-连接输入输出"><a href="#3-3-连接输入输出" class="headerlink" title="3.3 连接输入输出"></a>3.3 连接输入输出</h4><p>接下来需要创建改变音效的节点，并将这些节点连接起来，最终通过默认输出设备（通常是是设备扬声器）实质输出声音。<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/AudioContext/destination" target="_blank" rel="external">AudioContext.destination</a>就是最后需要连接的输出设备节点。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 以振荡器为例</span></div><div class="line"><span class="keyword">var</span> oscillator = audioCtx.createOscillator();</div><div class="line"><span class="keyword">var</span> gainNode = audioCtx.createGain();</div><div class="line"></div><div class="line">oscillator.connect(gainNode);</div><div class="line">gainNode.connect(audioCtx.destination);</div></pre></td></tr></table></figure>
<p>当然还有很多增益相关的节点，比如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> analyser = audioCtx.createAnalyser();  <span class="comment">//该节点可以从音频里提取时间、频率或者其它数据。</span></div><div class="line"><span class="keyword">var</span> distortion = audioCtx.createWaveShaper(); <span class="comment">//接口表示一个非线性的扭曲常被用来添加温暖的感觉。</span></div><div class="line"><span class="keyword">var</span> gainNode = audioCtx.createGain(); <span class="comment">//接口表示音量变更</span></div><div class="line"><span class="keyword">var</span> biquadFilter = audioCtx.createBiquadFilter(); <span class="comment">//表示一个简单的低阶滤波器</span></div><div class="line"><span class="keyword">var</span> convolver = audioCtx.createConvolver(); <span class="comment">//对给定的 AudioBuffer 执行线性卷积，通常用于实现混响效果。</span></div><div class="line"></div><div class="line">source = audioCtx.createMediaStreamSource(stream);</div><div class="line">source.connect(analyser);</div><div class="line">analyser.connect(distortion);</div><div class="line">distortion.connect(biquadFilter);</div><div class="line">biquadFilter.connect(convolver);</div><div class="line">convolver.connect(gainNode);</div><div class="line">gainNode.connect(audioCtx.destination);</div></pre></td></tr></table></figure>
<p>如果你一股脑添加了如上的节点，就会得到下面的音频节点图。这些节点都可以做对应的设置，来达到复杂的音频调节效果，这里就不做展开了，因为我也展不开……</p>
<p><img src="./images/web_audio_api/4.png" alt="音频图"></p>
<h4 id="3-4-设置音调、声音大小并播放"><a href="#3-4-设置音调、声音大小并播放" class="headerlink" title="3.4 设置音调、声音大小并播放"></a>3.4 设置音调、声音大小并播放</h4><p>终于到最后了，下面简单的做个设置就开始放吧：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">oscillator.type = <span class="string">'sine'</span>; <span class="comment">// sine 表示正弦波形 — 其他的波形值可以是 'square', 'sawtooth', 'triangle' and 'custom'</span></div><div class="line">oscillator.frequency.value = <span class="number">2500</span>; <span class="comment">// 单位是赫兹</span></div><div class="line">gainNode.gain.value = <span class="number">2</span>; <span class="comment">// 默认值是1</span></div><div class="line">oscillator.start(); <span class="comment">// 开始播放</span></div></pre></td></tr></table></figure>
<p>具体接口请参考<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Audio_API" target="_blank" rel="external">Web_Audio_API</a></p>
<h5 id="3-5-自产demo"><a href="#3-5-自产demo" class="headerlink" title="3.5 自产demo"></a>3.5 自产demo</h5><p>下面就上一个简单的demo，过程是利用XHR获取一个mp3文件，解码后播放，加了调节音量的按钮。</p>
<p><a href="https://github.com/fenglai0802/demo-list/tree/master/web_audio_api" target="_blank" rel="external">demo</a></p>
<p> PS:</p>
<ul>
<li><a href="https://github.com/ScottMichaud/AudioSampleLoader/blob/master/AudioSampleLoader.js" target="_blank" rel="external">AudioSampleLoader</a>这个库可以帮你简化XHR/buffer的操作。</li>
</ul>
<ul>
<li>Web Audio API的具体资料可以参考：<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Audio_API" target="_blank" rel="external">Web_Audio_API</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Web-Audio-API-Advance&quot;&gt;&lt;a href=&quot;#Web-Audio-API-Advance&quot; class=&quot;headerlink&quot; title=&quot;Web Audio API Advance&quot;&gt;&lt;/a&gt;Web Audio API Advance&lt;/
    
    </summary>
    
    
      <category term="web audio api" scheme="https://fenglai0802.github.io/tags/web-audio-api/"/>
    
  </entry>
  
  <entry>
    <title>Web Audio API history</title>
    <link href="https://fenglai0802.github.io/2017/03/01/Web-Audio-API-history/"/>
    <id>https://fenglai0802.github.io/2017/03/01/Web-Audio-API-history/</id>
    <published>2017-03-01T11:33:19.000Z</published>
    <updated>2017-03-01T11:34:18.000Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li><p><code>&lt;bgsound&gt;</code>:</p>
<p> 早在1996年，IE3.0定义了<bgsound>标签，这应该是web最早的一个能播放音频的标签，但是它没有成为标准，始终只有IE支持。提供的功能比较有限，就是自动播放，支持.wav|.mid|.ua格式音频。<br> 当时最早的个人blog中用来播放背景音乐的代码就是用<code>&lt;bgsound&gt;</code>实现的。</bgsound></p>
</li>
<li><p><code>&lt;embed&gt;</code></p>
<p> OK，这个时候当时的浏览器厂商大哥NetScape坐不住了，没多久就退出了类似的功能标签<code>&lt;embed&gt;</code>。<br> 其相对于<code>&lt;bgsound&gt;</code>的特色：</p>
<ul>
<li>添加了一点交互，可以暂停/播放(可选)。</li>
<li><p>不仅仅支持音频格式文件，还支持当时比较高端的VRML Live3D的图形动画。</p>
<p>大哥发话，很快小弟safari，opare，firefox就纷纷跟进支持<code>&lt;embed&gt;</code>。</p>
</li>
</ul>
</li>
<li><p><code>&lt;object&gt;</code></p>
<p> 1994年W3C成立。1997年，随着HTML4的到来，W3C引入了 <code>&lt;object&gt;</code>标签，包括了图片、音频、视频等格式文件。可以说是第一款跨浏览器的音频播放标签。但是这个标签也有自己的弊端，例如标签臃肿，依赖插件，SEO困难等。</p>
</li>
<li><p><code>&lt;audio&gt;</code></p>
<p> 2008年，第一份正式的HTML5草案发布，引入了新的富媒体元素<code>&lt;video&gt;</code>， <code>&lt;audio&gt;</code>，<code>&lt;canvas&gt;</code>，这些标签的引入最大目的还是为了减少web富媒体应用对插件的依赖。从标签名就能区分功能，这点也非常有利于搜索引擎去索引资源。相比<code>&lt;object&gt;</code>，其有一下特点：</p>
<ul>
<li>标签语义化，结构简单；</li>
<li>脱离插件；</li>
<li><p>简单的js内置方法以及事件交互。</p>
<p>同样，也有缺陷：</p>
</li>
<li><p>缺少对音频数据的访问权限，在需要更动感的交互和更复杂的音效需求面前就显得力不从心。</p>
</li>
</ul>
</li>
<li><p><code>[Audio Data API]</code></p>
<p> 为了满足更复杂的需求，Mozilla社区又开始搞事，提出了<a href="https://wiki.mozilla.org/Audio_Data_API" target="_blank" rel="external">Audio Data API</a>，对<code>&lt;audio&gt;</code>标签进行了js能力方面的扩展，这套API主要是以提供读取写入音频数据接口为主。不过到现在基本已经废弃了，因为很多音频的专业效果处理需要涉及大量波形相关处理算法，对于普通开发者来说，成本太高，这也是为什么最后W3C推荐WEB AUDIO API了。</p>
</li>
<li><p><code>[Web Audio API]</code></p>
<p> 这套API最早是由Chrome社区提供并支持的，这是一套全新的相对独立的接口系统。对音频文件拥有更高的处理权限以及<strong>内置相关的音频专业效果处理</strong>（这一点很关键），可以完全独立于<code>&lt;audio&gt;</code>标签而存在。<br> Web Audio API的特点：</p>
<ol>
<li>更精确的时间控制；</li>
<li>可以完全独立<code>&lt;audio&gt;</code>，允许更多音频文件同事播放，用于游戏或者复杂音频应用场景；</li>
<li>模块化路由链接方式，让音频操作更加灵活形象；</li>
<li>实时的频域，时域数据访问/操作；</li>
<li><p>更多专业的音频处理方法</p>
<ol>
<li>音道分离/合并；</li>
<li>音频延时效果；</li>
<li>内置频率滤波器；</li>
<li>音频空间感效果以及多普勒效应模拟；</li>
<li>音频卷积运算（用于声场环境模拟）；</li>
<li>自定义波形生成器；</li>
<li>波形非线性失真处理。</li>
</ol>
</li>
</ol>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;&amp;lt;bgsound&amp;gt;&lt;/code&gt;:&lt;/p&gt;
&lt;p&gt; 早在1996年，IE3.0定义了&lt;bgsound&gt;标签，这应该是web最早的一个能播放音频的标签，但是它没有成为标准，始终只有IE支持。提供的功能比较有限，就是自动播放，支持.wa
    
    </summary>
    
    
      <category term="web audio api" scheme="https://fenglai0802.github.io/tags/web-audio-api/"/>
    
  </entry>
  
  <entry>
    <title>ios和android使用同一个二维码实现跳转下载链接</title>
    <link href="https://fenglai0802.github.io/2017/02/28/%E6%89%AB%E6%8F%8F%E4%BA%8C%E7%BB%B4%E7%A0%81%E8%B7%B3%E8%BD%AC%E5%88%B0ios%E6%88%96android%E7%9A%84%E4%B8%8B%E8%BD%BD%E5%9C%B0%E5%9D%80/"/>
    <id>https://fenglai0802.github.io/2017/02/28/扫描二维码跳转到ios或android的下载地址/</id>
    <published>2017-02-28T08:45:29.000Z</published>
    <updated>2017-02-28T12:47:28.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="需求：扫描一个二维码，根据手机系统跳转到对应的下载页。ios扫描跳转到appstore，android扫描跳转到对应的浏览器或者市场下载。"><a href="#需求：扫描一个二维码，根据手机系统跳转到对应的下载页。ios扫描跳转到appstore，android扫描跳转到对应的浏览器或者市场下载。" class="headerlink" title="需求：扫描一个二维码，根据手机系统跳转到对应的下载页。ios扫描跳转到appstore，android扫描跳转到对应的浏览器或者市场下载。"></a>需求：扫描一个二维码，根据手机系统跳转到对应的下载页。ios扫描跳转到appstore，android扫描跳转到对应的浏览器或者市场下载。</h4><p>注意点：</p>
<ul>
<li>如果在微信中扫描二维码，需要手动跳转到手机的浏览器才能跳到下载页面。因为微信浏览器是不支持直接打开App Store页面的，以前可以通过微信中“查看原文“的function来跳转，微信升了几个版本又不行了，所以写了一个alert引导用户打开浏览器，蠢是蠢了点，但是靠谱。</li>
<li>如果要copy使用，改一下的url就好。</li>
</ul>
<p>下面直接上代码：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div></pre></td><td class="code"><pre><div class="line">	</div><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"txt"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">var</span> iosUrl = <span class="string">'https://itunes.apple.com/fr/app/wang-yi-dong-jianar-dong-cha/id1142482530?mt=8'</span>;  <span class="comment">//AppStore下载地址</span></div><div class="line">    <span class="keyword">var</span> anUrl = <span class="string">'http://www.lofter.com/rsc/android/loftcam.apk'</span>;  <span class="comment">//android下载地址</span></div><div class="line">    <span class="keyword">var</span> defaultUrl = <span class="string">'http://dongjian.163.com/'</span>;  <span class="comment">// pc端主页</span></div><div class="line"></div><div class="line">    jump(iosUrl, anUrl, defaultUrl);</div><div class="line"></div><div class="line">    <span class="comment">// 去下载</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">jump</span>(<span class="params">iosUrl, anUrl, defaultUrl</span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> ua = navigator.userAgent, appVer = navigator.appVersion;</div><div class="line">        <span class="keyword">var</span> isAndroid = ua.indexOf(<span class="string">'Android'</span>) &gt; <span class="number">-1</span> || ua.indexOf(<span class="string">'Linux'</span>) &gt; <span class="number">-1</span>;</div><div class="line">        <span class="keyword">var</span> isIOS = !!ua.match(<span class="regexp">/\(i[^;]+;( U;)? CPU.+Mac OS X/</span>);</div><div class="line">        <span class="comment">// 是安卓浏览器</span></div><div class="line">        <span class="keyword">if</span> (isAndroid) &#123;</div><div class="line">            <span class="built_in">window</span>.location.href = anUrl; <span class="comment">// 跳android端下载地址</span></div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 是iOS浏览器</span></div><div class="line">        <span class="keyword">if</span> (isIOS) &#123;</div><div class="line">            <span class="built_in">window</span>.location.href = iosUrl; <span class="comment">// 跳AppStore下载地址</span></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 是微信内部webView</span></div><div class="line">        <span class="keyword">if</span> (isWeixn()) &#123;</div><div class="line">            <span class="comment">// window.location.href = iosUrl; // 跳AppStore下载地址</span></div><div class="line">            <span class="keyword">var</span> txtNode = <span class="built_in">document</span>.createTextNode(<span class="string">'请点击右上角按钮, 点击使用浏览器打开'</span>);</div><div class="line">            <span class="built_in">document</span>.querySelector(<span class="string">'#txt'</span>).appendChild(txtNode);</div><div class="line">            alert(<span class="string">"请点击右上角按钮, 点击使用浏览器打开"</span>);</div><div class="line"></div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 是PC端</span></div><div class="line">        <span class="keyword">if</span> (isPC()) &#123;</div><div class="line">            <span class="built_in">window</span>.location.href = defaultUrl;  <span class="comment">// 公司主页</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 是微信浏览器</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">isWeixn</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">var</span> ua = navigator.userAgent.toLowerCase();</div><div class="line">        <span class="keyword">if</span>(ua.match(<span class="regexp">/MicroMessenger/i</span>)==<span class="string">"micromessenger"</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">isPC</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> uaInfo = navigator.userAgent;</div><div class="line">        <span class="keyword">var</span> agents = [<span class="string">"Android"</span>, <span class="string">"iPhone"</span>,</div><div class="line">            <span class="string">"SymbianOS"</span>, <span class="string">"Windows Phone"</span>,</div><div class="line">            <span class="string">"iPad"</span>, <span class="string">"iPod"</span>];</div><div class="line">        <span class="keyword">var</span> flag = <span class="literal">true</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> v = <span class="number">0</span>; v &lt; agents.length; v++) &#123;</div><div class="line">            <span class="keyword">if</span> (uaInfo.indexOf(agents[v]) &gt; <span class="number">0</span>) &#123;</div><div class="line">                flag = <span class="literal">false</span>;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> flag;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;需求：扫描一个二维码，根据手机系统跳转到对应的下载页。ios扫描跳转到appstore，android扫描跳转到对应的浏览器或者市场下载。&quot;&gt;&lt;a href=&quot;#需求：扫描一个二维码，根据手机系统跳转到对应的下载页。ios扫描跳转到appstore，android
    
    </summary>
    
    
      <category term="二维码" scheme="https://fenglai0802.github.io/tags/%E4%BA%8C%E7%BB%B4%E7%A0%81/"/>
    
      <category term="跳转" scheme="https://fenglai0802.github.io/tags/%E8%B7%B3%E8%BD%AC/"/>
    
      <category term="下载" scheme="https://fenglai0802.github.io/tags/%E4%B8%8B%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>函数式编程</title>
    <link href="https://fenglai0802.github.io/2017/02/27/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    <id>https://fenglai0802.github.io/2017/02/27/函数式编程/</id>
    <published>2017-02-27T12:58:02.000Z</published>
    <updated>2017-02-28T09:27:34.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h3><p><strong>函数式编程</strong>（通常简称为FP）是指通过符合<strong>纯函数</strong>来构建软件的过程。它避免了<strong>共享状态（share state）</strong>，<strong>易变的数据（mutable data）</strong>以及<strong>副作用（side-effects）</strong>。函数式编程是一种编程范式，一种软件构建的思维方式。</p>
<p>以下这些名词定义中蕴含了许多思想，只有理解了它们，才能够开始掌握函数式编程真正的意义：</p>
<ul>
<li>纯函数（Pure functions）</li>
<li>函数复合（Function composition）</li>
<li>避免共享状态（Avoid shared state）</li>
<li>避免改变状态（Avoid mutating state）</li>
<li>避免副作用（Avoid side effects）</li>
</ul>
<h4 id="1-纯函数"><a href="#1-纯函数" class="headerlink" title="1.纯函数"></a>1.纯函数</h4><ul>
<li>给它同样的输入，总是返回同样的结果；</li>
<li>没有副作用；</li>
</ul>
<p>纯函数有着许多对函数式编程而言非常重要的属性，包括引用透明（你可以将一个函数调用替换成它的结果值，而不会对程序的运行造成影响。详细：<a href="http://zcfy.cc/article/master-the-javascript-interview-what-is-a-pure-function-2186.html" target="_blank" rel="external">什么是纯函数</a></p>
<h4 id="2-函数复合"><a href="#2-函数复合" class="headerlink" title="2.函数复合"></a>2.函数复合</h4><ul>
<li>函数复合是结合两个或多个函数，从而产生一个新函数或进行某些计算的过程。eg:<code>f(g(x))</code></li>
</ul>
<p>详细：<a href="http://zcfy.cc/article/master-the-javascript-interview-what-is-function-composition-2160.html" target="_blank" rel="external">函数复合</a></p>
<h4 id="3-共享状态"><a href="#3-共享状态" class="headerlink" title="3.共享状态"></a>3.共享状态</h4><ul>
<li><strong>共享状态</strong> 的意思是任意变量、对象或者内存空间存在于共享作用域下，或者作为对象的属性在各个作用域之间被传递。共享作用域包括全局作用域和闭包作用域。</li>
</ul>
<p>同步竞争和调用时序变更导致的问题都是共享状态常见的bug。</p>
<ul>
<li>同步竞争：举个例子，操作A向服务器请求改变B的状态，然后马上用C操作向服务器发送请求，该请求也会改变B的状态，不幸的是C操作有可能早于A返回，这就导致了同步竞争的bug。</li>
<li>调用时序变更：这个好理解，因为共享状态操作是有时序的，如果颠倒执行顺序就会导致共享状态出现错乱。</li>
</ul>
<h4 id="4-不可变性"><a href="#4-不可变性" class="headerlink" title="4.不可变性"></a>4.不可变性</h4><p>一个<strong>不可变的（immutable）对象</strong>是指一个对象不会在它创建之后被改变。不可变性是函数式编程的一个核心概念，因为没有它，你的程序中的数据流是有损的。</p>
<p>JavaScript 提供了一个方法，能够<strong>浅冻结</strong>一个对象：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">const</span> a = <span class="built_in">Object</span>.freeze(&#123;</div><div class="line">  foo: <span class="string">'Hello'</span>,</div><div class="line">  bar: <span class="string">'world'</span>,</div><div class="line">  baz: <span class="string">'!'</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line">a.foo = <span class="string">'Goodbye'</span>;</div><div class="line"><span class="comment">// Error: Cannot assign to read only property 'foo' of object Object</span></div></pre></td></tr></table></figure>
<p>但是深层仍旧可以被改变。</p>
<p>在许多函数式编程语言中，有特殊的不可变数据结构，被称为 <strong>trie 数据结构</strong>(trie 的发音为 tree)，这一结构有效地深冻结 —— 意味任何属性无论它的对象层级如何都不能被改变。</p>
<p>有一些 JavaScript 的库使用了 tries，包括 <a href="https://github.com/facebook/immutable-js" target="_blank" rel="external">Immutable.js</a> 和 <a href="https://github.com/swannodette/mori" target="_blank" rel="external">Mori</a>。</p>
<p>immutable更多使用实例：<a href="https://medium.com/javascript-scene/10-tips-for-better-redux-architecture-69250425af44" target="_blank" rel="external">10 Tips for Better Redux Architecture</a>。</p>
<p>ps: 在 JavaScript 中，很重要的一点是不要混淆了 <code>const</code> 和不变性。<code>const</code> 创建一个变量绑定，让该变量不能再次被赋值。<code>const</code> 并不创建不可变对象。你虽然不能改变绑定到这个变量名上的对象，但你仍然可以改变它的属性，这意味着 <code>const</code> 的变量仍然是可变的，而不是不可变的。</p>
<h4 id="5-副作用"><a href="#5-副作用" class="headerlink" title="5.副作用"></a>5.副作用</h4><p>副作用是指除了函数返回值以外，任何在函数调用之外观察到的应用程序状态改变。副作用包括：</p>
<ul>
<li>改变了任何外部变量或对象属性（例如，全局变量，或者一个在父级函数作用域链上的变量）</li>
<li>写日志</li>
<li>在屏幕输出</li>
<li>写文件</li>
<li>发网络请求</li>
<li>触发任何外部进程</li>
<li>调用另一个有副作用的函数</li>
</ul>
<h4 id="6-使用高阶函数提升重用性"><a href="#6-使用高阶函数提升重用性" class="headerlink" title="6.使用高阶函数提升重用性"></a>6.使用高阶函数提升重用性</h4><p><strong>高阶函数</strong>指的是一个函数以函数为参数，或以函数为返回值，或者既以函数为参数又以函数为返回值。高阶函数经常用于：</p>
<ul>
<li>抽象或隔离行为、作用，异步控制流程作为回调函数，promises，<a href="https://en.wikipedia.org/wiki/Monad_%28functional_programming%29" target="_blank" rel="external">monads</a>，等等……</li>
<li>创建可以泛用于各种数据类型的功能</li>
<li>部分应用于函数参数（偏函数应用）或创建一个柯里化的函数，用于复用或函数复合。</li>
<li>接受一个函数列表并返回一些由这个列表中的函数组成的复合函数。</li>
</ul>
<p>函数式编程倾向于复用一组通用的函数功能来处理数据。面向对象编程倾向于把方法和数据集中到对象上。那些被集中的方法只能用来操作设计好的数据类型，通常是那些包含在特定对象实例上的数据。</p>
<p>在函数式编程里，对任何类型的数据一视同仁。同样的 map() 操作可以 map 对象、字符串、数字或任何别的类型，因为它接受一个函数参数，来适当地操作给定类型。函数式编程通过使用高阶函数来实现这一技巧。</p>
<p>关于高阶函数就不展开了。自行google。</p>
<h4 id="7-命令式-vs-声明式"><a href="#7-命令式-vs-声明式" class="headerlink" title="7.命令式 vs 声明式"></a>7.命令式 vs 声明式</h4><p>函数式编程是<strong>声明式</strong>的，而不是<strong>命令式</strong>的，应用程序的状态通过纯函数流转。</p>
<ul>
<li>声明式：意思是说程序逻辑不需要通过明确描述控制流程来表达。程序抽象了控制流过程，花费大量代码描述的是数据流：即做什么。</li>
<li>命令式：程序花费大量代码来描述用来达成期望结果的特定步骤 —— 控制流：即如何做。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// 命令式</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> doubleMap = numbers =&gt; &#123;</div><div class="line">  <span class="keyword">const</span> doubled = [];</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; numbers.length; i++) &#123;</div><div class="line">    doubled.push(numbers[i] * <span class="number">2</span>);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> doubled;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(doubleMap([<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])); <span class="comment">// [4, 6, 8]</span></div><div class="line"></div><div class="line"><span class="comment">// 声明式</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> doubleMap = numbers =&gt; numbers.map(n =&gt; n * <span class="number">2</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(doubleMap([<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])); <span class="comment">// [4, 6, 8]</span></div><div class="line"></div><div class="line"><span class="comment">// 命令式 代码中频繁使用语句。语句是指一小段代码，它用来完成某个行为。</span></div><div class="line"><span class="comment">// 声明式 代码更多依赖表达式。表达式是指一小段代码，它用来计算某个值。</span></div></pre></td></tr></table></figure>
<h4 id="8-结论"><a href="#8-结论" class="headerlink" title="8.结论"></a>8.结论</h4><p>函数式编程偏好：</p>
<ul>
<li>使用纯函数而不是使用共享状态和副作用</li>
<li>让可变数据成为不可变的</li>
<li>用函数复合替代命令控制流</li>
<li>使用高阶函数来操作许多数据类型，创建通用、可复用功能取代只是操作集中的数据的方法。</li>
<li>使用声明式而不是命令式代码（关注做什么，而不是如何做）</li>
<li>使用表达式替代语句</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;函数式编程&quot;&gt;&lt;a href=&quot;#函数式编程&quot; class=&quot;headerlink&quot; title=&quot;函数式编程&quot;&gt;&lt;/a&gt;函数式编程&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;函数式编程&lt;/strong&gt;（通常简称为FP）是指通过符合&lt;strong&gt;纯函数&lt;/strong&gt;来
    
    </summary>
    
      <category term="JS" scheme="https://fenglai0802.github.io/categories/JS/"/>
    
    
      <category term="函数式编程" scheme="https://fenglai0802.github.io/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>HTTP/2 vs HTTP/1.X</title>
    <link href="https://fenglai0802.github.io/2017/02/26/HTTP/"/>
    <id>https://fenglai0802.github.io/2017/02/26/HTTP/</id>
    <published>2017-02-26T04:02:16.000Z</published>
    <updated>2017-02-26T04:02:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>HTTP/2 vs HTTP/1.X</p>
<h4 id="1-什么是HTTP-2"><a href="#1-什么是HTTP-2" class="headerlink" title="1. 什么是HTTP/2"></a>1. 什么是HTTP/2</h4><p>超文本传输协议第二版，是自HTTP协议1999年HTTP1.1发布后的首个更新，主要是基于SPDY/2协议（是google开发的基于TCP的应用层协议，它的设计目标是降低 50% 的页面加载时间。用以最小化网络延迟，提升网络速度，优化用户的网络体验）。</p>
<p>HTTP/2跟SPDY区别：</p>
<ul>
<li>HTTP/2支持明文HTTP传输，而SPDY强制使用HTTPS</li>
<li>HTTP/2消息头的压缩算法采用HPACK，而非SPDY采用的DELEFT</li>
</ul>
<h4 id="2-与HTTP-1-X相比，区别有："><a href="#2-与HTTP-1-X相比，区别有：" class="headerlink" title="2. 与HTTP/1.X相比，区别有："></a>2. 与HTTP/1.X相比，区别有：</h4><ol>
<li><p>HTTP/2采用的是二进制格式传输数据，而非HTTP/1.X文本格式。二进制格式在协议的解析和优化扩展上带来更多的优势和可能。比起文本格式，二进制协议解析更高效，错误更少。</p>
</li>
<li><p>HTTP/2是完全多路复用，而非HTTP/1.X有序并阻塞的。<strong>只需要一个连接即可实现并行</strong>，这个很关键，高效。直白的说就是所有请求都是通过一个TCP连接并发完成。HTTP/1.X虽然能利用一个连接完成多次请求，但是多个请求之间有先后顺序的，后面发送的请求必须等待前面的请求返回了才能发送响应。就会导致请求被阻塞，而HTTP/2做到了真正的并发请求。同时，流还支持优先级和流量控制。</p>
<p> HTTP/1.X 有个问题叫线端阻塞(head-of-line blocking), 它是指一个连接(connection)一次只提交一个请求的效率比较高, 多了就会变慢。 HTTP/1.1 试过用流水线(pipelining)来解决这个问题, 但是效果并不理想(数据量较大或者速度较慢的响应, 会阻碍排在他后面的请求). 此外, 由于网络媒介(intermediary )和服务器不能很好的支持流水线, 导致部署起来困难重重。而多路传输(Multiplexing)能很好的解决这些问题, 因为它能同时处理多个消息的请求和响应; 甚至可以在传输过程中将一个消息跟另外一个掺杂在一起。所以客户端只需要一个连接就能加载一个页面。<br> <img src="./images/HTTP/Multiplexing.png" alt="Multiplexing" title="Multiplexing"></p>
</li>
<li><p>HTTP/2 对消息头采用 HPACK 进行压缩传输，能够节省消息头占用的网络的流量，增大有效数据传输量。</p>
</li>
<li><p>Server Push：让服务器可以响应主动“推送”到客户端缓存中。例如服务端可以主动把 JS 和 CSS 文件推送给客户端，而不需要客户端解析 HTML 再发送这些请求。当客户端需要的时候，它已经在客户端了。</p>
</li>
</ol>
<h4 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h4><p>本文简化了很多 HTTP/2 协议中的具体细节，只描述了 HTTP/2 中主要特性实现的基本过程。</p>
<p>如果你想实现一个支持 HTTP/2 的服务器，那么你可以移步 <a href="https://http2.github.io/" target="_blank" rel="external">HTTP/2</a> 官网 做更多了解，它还提供了一份已经实现 HTTP/2 的项目列表： <a href="https://github.com/http2/http2-spec/wiki/Implementations" target="_blank" rel="external">https://github.com/http2/http2-spec/wiki/Implementations</a> 。</p>
<p>另外，关于 HTTP/2 性能如何，可以参考官方小组给出的例子： <a href="https://http2.akamai.com/demo" target="_blank" rel="external">https://http2.akamai.com/demo</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;HTTP/2 vs HTTP/1.X&lt;/p&gt;
&lt;h4 id=&quot;1-什么是HTTP-2&quot;&gt;&lt;a href=&quot;#1-什么是HTTP-2&quot; class=&quot;headerlink&quot; title=&quot;1. 什么是HTTP/2&quot;&gt;&lt;/a&gt;1. 什么是HTTP/2&lt;/h4&gt;&lt;p&gt;超文本传输协
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>grammar更改笔记</title>
    <link href="https://fenglai0802.github.io/2016/11/20/Atom%E4%B8%AD%E6%96%87%E4%BB%B6%E8%AF%86%E5%88%AB%E9%BB%98%E8%AE%A4%E8%AF%AD%E6%B3%95%E4%BF%AE%E6%94%B9/"/>
    <id>https://fenglai0802.github.io/2016/11/20/Atom中文件识别默认语法修改/</id>
    <published>2016-11-20T05:18:57.000Z</published>
    <updated>2016-11-20T06:02:32.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Atom中文件识别默认语法修改"><a href="#Atom中文件识别默认语法修改" class="headerlink" title="Atom中文件识别默认语法修改"></a>Atom中文件识别默认语法修改</h1><ul>
<li><em>需求</em>：公司使用自己开发的css预处理器mcss来进行web样式开发，这类文件的后缀为.mcss，在Atom中无法识别，因此每次打开这类文件，都需要ctrl+shift+L选择语言(grammar)版本，通常会选择scss或者less来代替一下。重复度比较大。</li>
<li><em>思路</em>：解决这个问题有2个办法：一个就是写个Atom插件，让Atom可以识别mcss语言；另一个就是将就策略，让Atom自动用scss或者less的语法来识别.mcss文件。考虑到办法一短时间无法实现（好吧，其实是因为菜），这里先用方法二处理下，后续有缘再进行插件的开发。</li>
</ul>
<h2 id="Atom语法介绍"><a href="#Atom语法介绍" class="headerlink" title="Atom语法介绍"></a>Atom语法介绍</h2><p>加载了一个文件以后，Atom会做一些事情来试图识别出文件的类型。大部分情况下，Atom 会通过文件的扩展名（.md 通常是一个 Markdown 文件，等等）来完成这项工作，但有时只通过扩展名难以判断，它会对文件内容进行一些检查来确定。</p>
<p>如果加载了一个 Atom 无法判断语法的文件，它会默认为是最简单的纯文本类型（Plain Text）。如果它把文件默认为纯文本，或者弄错了文件类型，再或者由于一些原因你想修改文件的当前作用语法，可以按下 ctrl-shift-L 调出语法选择器。</p>
<p><img src="./images/Atom中文件识别默认语法修改/grammar.png" alt=""></p>
<p>一旦手动修改了一个文件的语法，Atom会记住它，除非你将语法设置回自动检测，或者手动选择一个不同的语法。</p>
<p>语法选择器的功能在 <a href="https://github.com/atom/grammar-selector" target="_blank" rel="external">atom/grammar-selector</a> 这个 package 里实现。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>在Atom的配置文件夹目录下有一个init.coffee的文件，用于做Atom初始化设置。</p>
<p>在其中添加代码</p>
<pre><code># add &quot;.mcss&quot; to SCSS grammar:
for grammar of atom.grammars.grammars
  if grammar.name is &quot;Less&quot;
    grammar.fileTypes.push(&apos;mcss&apos;)
atom.grammars.onDidAddGrammar (grammar) -&gt;
  if grammar.name is &quot;Less&quot;
    grammar.fileTypes.push(&apos;mcss&apos;)
</code></pre><p>表示在Less的语法中，添加识别文件类型mcss。从而使mcss文件能够被当做Less识别</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Atom中文件识别默认语法修改&quot;&gt;&lt;a href=&quot;#Atom中文件识别默认语法修改&quot; class=&quot;headerlink&quot; title=&quot;Atom中文件识别默认语法修改&quot;&gt;&lt;/a&gt;Atom中文件识别默认语法修改&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;em&gt;需求&lt;/em&gt;：
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>文件上传组件小结</title>
    <link href="https://fenglai0802.github.io/2016/11/06/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%BB%84%E4%BB%B6%E5%B0%8F%E7%BB%93/"/>
    <id>https://fenglai0802.github.io/2016/11/06/文件上传组件小结/</id>
    <published>2016-11-06T07:05:50.000Z</published>
    <updated>2016-11-07T07:32:11.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="文件-图片上传组件小结"><a href="#文件-图片上传组件小结" class="headerlink" title="文件/图片上传组件小结"></a>文件/图片上传组件小结</h1><p>分为两部分来总结，第一部分为<em>自定义样式</em>，第二部分为<em>js实现</em>。</p>
<h2 id="一-自定义样式"><a href="#一-自定义样式" class="headerlink" title="一. 自定义样式"></a>一. 自定义样式</h2><p>通常来说，<code>input[type=file]</code>的默认样式都不能满足视觉的需求，所以需要套壳包装。常用的方式就是隐藏默认上传控件，并在其父级添加一个元素（比如label标签）来自定义样式，这样可以做到保留功能同时自定义样式。具体css代码如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//HTML5</div><div class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">''</span> <span class="attr">ref</span>=<span class="string">preview</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">"u-btn btn-upload"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">ref</span>=<span class="string">files</span>  <span class="attr">on-change</span>=<span class="string">&#123;this.fileChange()&#125;</span>&gt;</span>上传图片</div><div class="line"><span class="tag">&lt;/<span class="name">label</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">//CSS</div><div class="line">.u-btn &#123;   //基础按钮样式</div><div class="line">    font: inherit;</div><div class="line">    position:relative;</div><div class="line">    line-height: 34px;</div><div class="line">    display: inline-block;</div><div class="line">    box-sizing: border-box;</div><div class="line">    height: 34px;</div><div class="line">    margin: 0;</div><div class="line">    padding: 0 12px;</div><div class="line">    cursor: pointer;</div><div class="line">    text-decoration: none;</div><div class="line">    color: #444;</div><div class="line">    border: 1px solid #ddd;</div><div class="line">    -moz-border-radius: 3px;</div><div class="line">    border-radius: 3px;</div><div class="line">    background: #f4f4f4;</div><div class="line">    -webkit-appearance: none;</div><div class="line">&#125;</div><div class="line">.u-btn:focus, .u-btn:hover &#123;</div><div class="line">    text-decoration: none;border: 1px solid #adadad;background: #e5e5e5;</div><div class="line">&#125;</div><div class="line">.btn-upload &#123;  </div><div class="line">    overflow: hidden;</div><div class="line">    input &#123;</div><div class="line">        opacity: 0;</div><div class="line">        filter:alpha(opacity=0);</div><div class="line">        font-size: 100px;</div><div class="line">        position: absolute;</div><div class="line">        top: 0;right: 0</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="二-js实现"><a href="#二-js实现" class="headerlink" title="二. js实现"></a>二. js实现</h2><p>需求：上传单张图片，并能预览。</p>
<p>框架：<a href="https://github.com/regularjs/regular" target="_blank" rel="external">regular</a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 这里使用regular框架，不详细说明</span></div><div class="line"><span class="comment">// 在`input[type=file]`上绑定了`onchange`监听事件,回调为`fileChange`方法</span></div><div class="line">fileChange: <span class="function"><span class="keyword">function</span>(<span class="params">ev</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> input = <span class="keyword">this</span>.$refs.files;  <span class="comment">// regular获取节点的方式</span></div><div class="line">    <span class="keyword">var</span> preview = <span class="keyword">this</span>.$refs.preview;  <span class="comment">// 获取预览dom</span></div><div class="line">    <span class="keyword">var</span> file = input.files[<span class="number">0</span>]; <span class="comment">// 获取上传的文件</span></div><div class="line">    <span class="keyword">if</span> (!<span class="regexp">/\/(?:jpeg|jpg|png)/i</span>.test(file.type)) &#123; <span class="comment">//检查上传文件的类型，此处需要图片类型的文件，并且规定了后缀条件。</span></div><div class="line">        <span class="comment">//提示错误信息</span></div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">var</span> reader = <span class="keyword">new</span> FileReader();</div><div class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</div><div class="line">    reader.onload = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">var</span> result = self.img = <span class="keyword">this</span>.result; <span class="comment">// this指向reader,这个result即上传文件数据，将这个result用ajax传输即可。</span></div><div class="line"></div><div class="line">        <span class="comment">// 组件操作，可忽略</span></div><div class="line">        self.data.show = <span class="literal">true</span>;</div><div class="line">        self.data.str = <span class="string">'重新选择'</span></div><div class="line">        self.$emit(<span class="string">'upload'</span>);</div><div class="line"></div><div class="line">        preview.src = result; <span class="comment">// 预览dom设置src</span></div><div class="line"></div><div class="line">        <span class="comment">// console.log(preview.naturalWidth)</span></div><div class="line">        <span class="comment">// console.log(preview.naturalHeight)</span></div><div class="line">        <span class="comment">// 组件操作，可忽略</span></div><div class="line">        self.imgNatrualSize = &#123;</div><div class="line">            width: preview.naturalWidth,</div><div class="line">            height: preview.naturalHeight</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 获取文件名</span></div><div class="line">        <span class="keyword">var</span> imgName = input.value;</div><div class="line">        <span class="keyword">var</span> index = imgName.lastIndexOf(<span class="string">'\\'</span>);</div><div class="line">        self.imgName = index !== <span class="number">-1</span> ? imgName.slice(index+<span class="number">1</span>) : imgName;</div><div class="line"></div><div class="line">        input.value = <span class="string">''</span>; <span class="comment">// 清空图片上传框的值</span></div><div class="line"></div><div class="line">   &#125;;</div><div class="line"></div><div class="line">   reader.readAsDataURL(file); <span class="comment">// 将文件转成base64的格式.</span></div><div class="line">&#125;,</div></pre></td></tr></table></figure>
<h2 id="附录-FileReader-API简介"><a href="#附录-FileReader-API简介" class="headerlink" title="附录 FileReader API简介"></a>附录 FileReader API简介</h2><p>###1. FileReader对象的方法</p>
<p>FileReader 的实例拥有 4 个方法，其中 3 个用以读取文件，另一个用来中断读取。下面的表格列出了这些方法以及他们的参数和功能，需要注意的是 ，无论读取成功或失败，方法并不会返回读取结果，这一结果存储在 result属性中。</p>
<table>
<thead>
<tr>
<th style="text-align:left">方法名</th>
<th style="text-align:left">参数</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">abort</td>
<td style="text-align:left">none</td>
<td style="text-align:left">中断读取</td>
</tr>
<tr>
<td style="text-align:left">readAsBinaryString</td>
<td style="text-align:left">file</td>
<td style="text-align:left">将文件读取为二进制码</td>
</tr>
<tr>
<td style="text-align:left">readAsDataURL</td>
<td style="text-align:left">file</td>
<td style="text-align:left">将文件读取为 DataURL</td>
</tr>
<tr>
<td style="text-align:left">readAsText</td>
<td style="text-align:left">file</td>
<td style="text-align:left">将文件读取为文本</td>
</tr>
</tbody>
</table>
<p><em>readAsText</em>：该方法有两个参数，其中第二个参数是文本的编码方式，默认值为 UTF-8。这个方法非常容易理解，将文件以文本方式读取，读取的结果即是这个文本文件中的内容。</p>
<p><em>readAsBinaryString</em>：该方法将文件读取为二进制字符串，通常我们将它传送到后端，后端可以通过这段字符串存储文件。</p>
<p><em>readAsDataURL</em>：这是例子程序中用到的方法，该方法将文件读取为一段以 data: 开头的字符串，这段字符串的实质就是 Data URL，Data URL是一种将小文件直接嵌入文档的方案。这里的小文件通常是指图像与 html 等格式的文件。</p>
<h3 id="2-FileReader对象的事件"><a href="#2-FileReader对象的事件" class="headerlink" title="2. FileReader对象的事件"></a>2. FileReader对象的事件</h3><p>FileReader 包含了一套完整的事件模型，用于捕获读取文件时的状态，下面这个表格归纳了这些事件。</p>
<table>
<thead>
<tr>
<th style="text-align:left">事件</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">onabort</td>
<td style="text-align:left">中断时触发</td>
</tr>
<tr>
<td style="text-align:left">onerror</td>
<td style="text-align:left">出错时触发</td>
</tr>
<tr>
<td style="text-align:left">onload</td>
<td style="text-align:left">文件读取成功完成时触发</td>
</tr>
<tr>
<td style="text-align:left">onloadend</td>
<td style="text-align:left">读取完成触发，无论成功或失败</td>
</tr>
<tr>
<td style="text-align:left">onloadstart</td>
<td style="text-align:left">读取开始时触发</td>
</tr>
<tr>
<td style="text-align:left">onprogress</td>
<td style="text-align:left">读取中</td>
</tr>
</tbody>
</table>
<p>文件一旦开始读取，无论成功或失败，实例的 result 属性都会被填充。如果读取失败，则 result 的值为 null ，否则即是读取的结果，绝大多数的程序都会在成功读取文件的时候，抓取这个值。</p>
<pre><code>var reader = new FileReader();
reader.onload = function() {  
    this.result;  
};
</code></pre><p><em>ps</em> 可以利用这些事件制作文件读取的进度条，此处不详细展开，有空在做补充。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;文件-图片上传组件小结&quot;&gt;&lt;a href=&quot;#文件-图片上传组件小结&quot; class=&quot;headerlink&quot; title=&quot;文件/图片上传组件小结&quot;&gt;&lt;/a&gt;文件/图片上传组件小结&lt;/h1&gt;&lt;p&gt;分为两部分来总结，第一部分为&lt;em&gt;自定义样式&lt;/em&gt;，第二部分为
    
    </summary>
    
      <category term="JS" scheme="https://fenglai0802.github.io/categories/JS/"/>
    
    
      <category term="HTML5 API" scheme="https://fenglai0802.github.io/tags/HTML5-API/"/>
    
      <category term="文件上传" scheme="https://fenglai0802.github.io/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"/>
    
  </entry>
  
  <entry>
    <title>git子模块</title>
    <link href="https://fenglai0802.github.io/2016/09/17/git%E5%AD%90%E6%A8%A1%E5%9D%97/"/>
    <id>https://fenglai0802.github.io/2016/09/17/git子模块/</id>
    <published>2016-09-17T07:31:17.000Z</published>
    <updated>2016-09-17T07:37:50.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="git子模块"><a href="#git子模块" class="headerlink" title="git子模块"></a>git子模块</h1><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>在开发项目A时，需要依赖项目B（实时更新）。同时希望A,B能够独立处理。</p>
<h3 id="实际案例"><a href="#实际案例" class="headerlink" title="实际案例"></a>实际案例</h3><p>举例来说，现在我参与的项目<strong>网易有数（Youdata）</strong>，它依赖了一个独立开发的图形库<strong>NEV</strong>，他们是并行开发的。如果只是简单的将<strong>NEV</strong>的代码copy到Youdata中，显然是有点傻逼，因为无法自动更新NEV的迭代。</p>
<h3 id="处理方式"><a href="#处理方式" class="headerlink" title="处理方式"></a>处理方式</h3><p>Git 通过子模块处理这个问题。子模块允许你将一个 Git仓库当作另外一个Git仓库的子目录。这允许你克隆另外一个仓库到你的项目中并且保持你的提交相对独立。</p>
<h3 id="子模块相关操作："><a href="#子模块相关操作：" class="headerlink" title="子模块相关操作："></a>子模块相关操作：</h3><h4 id="1-添加子模块-git-submodule-add-url-path"><a href="#1-添加子模块-git-submodule-add-url-path" class="headerlink" title="1.添加子模块 $ git submodule add [url] [path]"></a>1.添加子模块 <code>$ git submodule add [url] [path]</code></h4><p>如</p>
<pre><code>$ git sub module add https://git.hz.netease.com/git/NEV/NEV.git src/webapp/res/nev
</code></pre><p>操作成功之后会生成一个.submodules的文件，其中记录了每个submodule的引用信息，知道在当前项目的位置以及仓库的所在。</p>
<h4 id="2-查看子模块-git-submodule"><a href="#2-查看子模块-git-submodule" class="headerlink" title="2.查看子模块 $ git submodule"></a>2.查看子模块 <code>$ git submodule</code></h4><p>如图</p>
<p><img src="./images/git子模块/1.png" alt=""></p>
<p>ps: 如果子模块前面有一个-，说明子模块文件还未检入（空文件夹）</p>
<h4 id="3-初始化子模块：-git-submodule-init-—-在首次检出仓库时运行一次"><a href="#3-初始化子模块：-git-submodule-init-—-在首次检出仓库时运行一次" class="headerlink" title="3.初始化子模块： $ git submodule init — 在首次检出仓库时运行一次"></a>3.初始化子模块： <code>$ git submodule init</code> — 在首次检出仓库时运行一次</h4><h4 id="4-更新子模块：-git-submodule-update"><a href="#4-更新子模块：-git-submodule-update" class="headerlink" title="4. 更新子模块：$ git submodule update"></a>4. 更新子模块：<code>$ git submodule update</code></h4><p>这个命令才是最常用的，每次子模块更新或者切换分支了，就执行一次。</p>
<h4 id="5-删除子模块："><a href="#5-删除子模块：" class="headerlink" title="5. 删除子模块："></a>5. 删除子模块：</h4><ul>
<li><code>$ git rm -cached [path]</code></li>
<li>编辑<code>.gitmodules</code>文件，删除对应的子模块配置</li>
<li>编辑<code>.git/config</code>文件，删除对应的子模块配置</li>
<li>最后删除子模块的目录</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;git子模块&quot;&gt;&lt;a href=&quot;#git子模块&quot; class=&quot;headerlink&quot; title=&quot;git子模块&quot;&gt;&lt;/a&gt;git子模块&lt;/h1&gt;&lt;h3 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;
    
    </summary>
    
      <category term="git" scheme="https://fenglai0802.github.io/categories/git/"/>
    
    
      <category term="git" scheme="https://fenglai0802.github.io/tags/git/"/>
    
      <category term="子模块" scheme="https://fenglai0802.github.io/tags/%E5%AD%90%E6%A8%A1%E5%9D%97/"/>
    
  </entry>
  
  <entry>
    <title>图解密码技术总结</title>
    <link href="https://fenglai0802.github.io/2016/09/14/%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"/>
    <id>https://fenglai0802.github.io/2016/09/14/图解密码技术总结/</id>
    <published>2016-09-14T07:42:58.000Z</published>
    <updated>2016-09-14T08:25:08.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《图解密码技术》总结"><a href="#《图解密码技术》总结" class="headerlink" title="《图解密码技术》总结"></a>《图解密码技术》总结</h1><h3 id="一-历史上的密码"><a href="#一-历史上的密码" class="headerlink" title="一. 历史上的密码"></a>一. 历史上的密码</h3><h5 id="1-1-凯撒密码："><a href="#1-1-凯撒密码：" class="headerlink" title="1.1. 凯撒密码："></a>1.1. <strong>凯撒密码</strong>：</h5><ul>
<li>将明文按照字母表进行一定的“平移”来进行加密的加密算法。</li>
</ul>
<p><img src="./images/图解密码技术总结/1.1.png" alt=""></p>
<h5 id="1-2-简单替换密码："><a href="#1-2-简单替换密码：" class="headerlink" title="1.2. 简单替换密码："></a>1.2. <strong>简单替换密码</strong>：</h5><ul>
<li>两套字母表进行乱序一一对应，那么无论哪种对应关系都可以作为密码来使用。这种将明文中用到的字母表替换成另一套字母表的密码就是简单替换密码（simple substitution cipher）。如下图。</li>
</ul>
<p><img src="./images/图解密码技术总结/1.2.png" alt=""></p>
<h5 id="1-3-Enigma："><a href="#1-3-Enigma：" class="headerlink" title="1.3. Enigma："></a>1.3. <strong>Enigma</strong>：</h5><ul>
<li>相信很多人看过由卷福饰演图灵的电影《模仿游戏》，那么对于二战时期大名鼎鼎的德国密码机Enigma一定不陌生了。</li>
<li>Enigma在德语中的意思就是“谜”。</li>
<li>发明之初是作为商用的，到了纳粹时期，经过改良后用于军事用途。</li>
<li>Enigma是一种由键盘、齿轮、电池和灯泡组成的机器。通过一台机器可以完成加密解密两种操作。</li>
<li>其实<strong>Enigma相当于一个密码算法</strong>， 它并不依赖于<strong>隐蔽式安全性</strong>（security by obscurity）—隐蔽式安全性：顾名思义就是依靠算法的隐蔽性来获得安全保障，一旦算法被曝光就会被破解。而Enigma密码机就算被密码破译者得到，只要不知道Enigma的设置（相当于密钥），就无法破译密码。</li>
</ul>
<h6 id="1-3-1-下图为Enigma进行加密通信的过程图。"><a href="#1-3-1-下图为Enigma进行加密通信的过程图。" class="headerlink" title="1.3.1 下图为Enigma进行加密通信的过程图。"></a>1.3.1 下图为Enigma进行加密通信的过程图。</h6><p><img src="./images/图解密码技术总结/1.3.png" alt=""></p>
<h6 id="1-3-2-Enigma加密"><a href="#1-3-2-Enigma加密" class="headerlink" title="1.3.2 Enigma加密"></a>1.3.2 Enigma加密</h6><p>下图为Enigma进行加密nacht的过程图。</p>
<p><img src="./images/图解密码技术总结/1.4.png" alt=""></p>
<p>在进行通信之前，发送者和接受者都需要持有国防军密码本，这里面记载了发送者和接受者需要使用的每日密码。如果有一本国防军密码本被缴获，那就需要全部替换新的密码本。这里就涉及到密钥的配送问题。</p>
<ol>
<li><p>设置Enigma</p>
<p> 发送者查阅国防军密码本，找到当天的<strong>每日密码</strong>，并按照该密码设置Enigma。</p>
</li>
<li><p>加密通信密码</p>
<p> 接下来，发送者需要想出3个字母（这里假设为psv），并将其加密。这3个字母称为<strong>通信密码</strong>。</p>
<p> 由于Enigma的时代，无线电的质量很差，可能发生通信错误。所以通信密码需要连续输入两次（psvpsv），以便接受者可以进行校验。在Enigma中输入psvpsv这6个字母，则会得到对应的密文并记录，假设密文为ATCDVT（密文用大写字母表示）。</p>
<p> 这里可以看出，每日密码其实是用来加密通信密钥的密钥。这样的密钥，一般称为<strong>密钥加密密钥</strong>（Key Encryptiong Key，KEK）。</p>
</li>
<li><p>重新设置Enigma</p>
<p> 此时，根据通信密码（psv）重新设置Enigma。</p>
</li>
<li><p>加密信息</p>
<p> 接下来，发送者就可以对消息进行加密了。假设消息（明文）为nacht，进过加密得到KXNWP。</p>
</li>
<li><p>拼接</p>
<p> 最后，将2中得到的通信密码“ATCDVT”与加密后的消息“KXNWP”进行拼接，将“ATCDVTKXNWP”作为电文通过无线电发送出去。</p>
</li>
</ol>
<h6 id="1-3-3-Enigma解密"><a href="#1-3-3-Enigma解密" class="headerlink" title="1.3.3 Enigma解密"></a>1.3.3 Enigma解密</h6><p>理解了加密步骤，解密就简单了。</p>
<ul>
<li>首先将密文分成两部分，即开头6个字母ATCDVT和剩下的字母KXNWP。</li>
<li>根据和发送者相同的每日密码设置Enigma。将ATCDVT破译得到psvpsv。</li>
<li>根据psv设置Enigma。</li>
<li>然后破译剩下的字母KXNWP，得到明文nacht。</li>
</ul>
<h6 id="1-3-4-Enigma的弱点"><a href="#1-3-4-Enigma的弱点" class="headerlink" title="1.3.4 Enigma的弱点"></a>1.3.4 Enigma的弱点</h6><ul>
<li>通信密码连续输入两次。</li>
<li>通信密码人为选定。理论上通信密码应该具有不可预测性。</li>
<li>必须派发国防军密码本。前面也说了，如果泄露一本，就需要全部替换新的。</li>
</ul>
<p>===</p>
<h3 id="二-对称密码"><a href="#二-对称密码" class="headerlink" title="二. 对称密码"></a>二. 对称密码</h3><ul>
<li>所谓对称密码，就是说加密和解密使用的是相同的密钥。</li>
<li>算法的核心是利用位运算中“异或”的方式来实现的。简单的讲：“01”组成的比特序列经过与密钥的一次“异或”<br>即可得到密文，再和相同的密钥进行一次“异或”就能还原明文。</li>
<li>对称密码的算法：DES、三重DES、AES（AES的标准所选定的密码算法叫作Rijndael）。</li>
</ul>
<h4 id="2-1-一次性密码本-—-绝对不会被破译的密码"><a href="#2-1-一次性密码本-—-绝对不会被破译的密码" class="headerlink" title="2.1 一次性密码本 — 绝对不会被破译的密码"></a>2.1 一次性密码本 — 绝对不会被破译的密码</h4><ul>
<li>原理是： 将明文和一串随机的比特序列进行XOR运算。</li>
<li>那么为什么它是无法破译的呢：无法破译并不是说不能解出明文，而是说无法判断它是否是正确的明文，因为在解密的过程（暴力破解）中所有的排列组合都会出现，因此就无法判断哪一个才是正确的明文。</li>
</ul>
<p>===</p>
<h3 id="三-公钥密码—用公钥加密，用私钥解密"><a href="#三-公钥密码—用公钥加密，用私钥解密" class="headerlink" title="三. 公钥密码—用公钥加密，用私钥解密"></a>三. 公钥密码—用公钥加密，用私钥解密</h3><ul>
<li>书里关于投币寄存柜的比喻很好：钱是关闭寄存柜的密钥，钥匙是打开寄存柜的密钥。类比公钥密码，钱就是公钥，谁都可以用来加密寄存柜，但是要打开寄存柜只能用私钥“钥匙”。</li>
</ul>
<h4 id="3-1-密钥配送问题"><a href="#3-1-密钥配送问题" class="headerlink" title="3.1 密钥配送问题"></a>3.1 密钥配送问题</h4><p>如果密钥如同密文一样通过网络直接发送，那么也很容易被窃听。那么如何解决这个问题呢。</p>
<ul>
<li>通过事先共享的密钥来解决。</li>
<li>通过密钥分配中心来解决。</li>
<li>通过Diffie-Hellman密钥交换来解决。</li>
<li>通过公钥密码来解决。</li>
</ul>
<h4 id="3-2-那么如何通过公钥密钥来解决密钥配送问题呢"><a href="#3-2-那么如何通过公钥密钥来解决密钥配送问题呢" class="headerlink" title="3.2 那么如何通过公钥密钥来解决密钥配送问题呢"></a>3.2 那么如何通过公钥密钥来解决密钥配送问题呢</h4><h5 id="3-2-1-首先来介绍下公钥的通信流程"><a href="#3-2-1-首先来介绍下公钥的通信流程" class="headerlink" title="3.2.1 首先来介绍下公钥的通信流程"></a>3.2.1 首先来介绍下公钥的通信流程</h5><ol>
<li>Bob生成一个包含公钥和私钥的密钥对。私钥有Bob自己保管。</li>
<li>Bob将公钥发送给Alice。Bob的公钥被窃听者Eve获取也没关系。将公钥发送给Alice表示让他用这个公钥加密消息并发送给Bob。</li>
<li>Alice用Bob的公钥加密消息，加密后的消息只能用Bob的私钥才能解密。Alice的公钥是无法解密的。</li>
<li>Alice将密文发送给Bob。这样密文就算被窃听也没有关系。</li>
<li>Bob用私钥进行解密。</li>
</ol>
<p><img src="./images/图解密码技术总结/3.1.png" alt=""></p>
<h5 id="3-2-2-解决密钥配送问题"><a href="#3-2-2-解决密钥配送问题" class="headerlink" title="3.2.2 解决密钥配送问题"></a>3.2.2 解决密钥配送问题</h5><p>因此，我们可以用公钥来加密对称密码的密钥，从而解决密钥配送的问题。</p>
<h5 id="3-2-3-公钥密码无法解决的问题"><a href="#3-2-3-公钥密码无法解决的问题" class="headerlink" title="3.2.3 公钥密码无法解决的问题"></a>3.2.3 公钥密码无法解决的问题</h5><ol>
<li>公钥密码的速度只有对称密码的几百分之一。速度问题如何解决。</li>
<li>如何判断公钥的正确合法性，这个问题是公钥认证的问题。举例：<strong>中间人攻击</strong>，如图</li>
</ol>
<p><img src="./images/图解密码技术总结/3.2.png" alt=""></p>
<h5 id="3-2-4-公钥密码的算法"><a href="#3-2-4-公钥密码的算法" class="headerlink" title="3.2.4 公钥密码的算法"></a>3.2.4 公钥密码的算法</h5><ul>
<li>算法的核心是利用mod运算（取余运算）</li>
<li>简单介绍下现在使用最广泛的公钥密码算法 — RSA<ul>
<li>密文 = 明文 E MOD N （RSA加密：明文的E次方除以N的余数）</li>
<li>明文 = 密文 D MOD N （RSA解密：密文的D次方除以N的余数）</li>
<li>E和N的组合就是公钥</li>
<li>D和N的组合就是私钥</li>
</ul>
</li>
</ul>
<p>===</p>
<h3 id="四-混合密码系统-—-用对称密码提高速度，用公钥密码保护会话密钥"><a href="#四-混合密码系统-—-用对称密码提高速度，用公钥密码保护会话密钥" class="headerlink" title="四. 混合密码系统 — 用对称密码提高速度，用公钥密码保护会话密钥"></a>四. 混合密码系统 — 用对称密码提高速度，用公钥密码保护会话密钥</h3><p>在3.2.3中提到公钥密码还有两个很大的问题。一是速度问题，二是认证问题。这一节介绍的混合密码系统可以解决第一个速度问题。第二个问题在后面的小节中介绍。</p>
<h4 id="4-1-混合密码系统组成"><a href="#4-1-混合密码系统组成" class="headerlink" title="4.1 混合密码系统组成"></a>4.1 混合密码系统组成</h4><ul>
<li>用对称密码加密消息</li>
<li>通过伪随机数生成器生成对称密码加密中使用的会话秘钥</li>
<li>用公钥密码加密会话密钥(这就是解决速度问题的方法，因为对称密码的密钥一般比消息本身要短)</li>
<li>从混合密码系统外部赋予公钥密码加密时使用的密钥</li>
</ul>
<h4 id="4-2-混合密码系统的加密过程"><a href="#4-2-混合密码系统的加密过程" class="headerlink" title="4.2 混合密码系统的加密过程"></a>4.2 混合密码系统的加密过程</h4><p><img src="./images/图解密码技术总结/4.1.png" alt=""></p>
<h4 id="4-3-混合密码系统的解密过程"><a href="#4-3-混合密码系统的解密过程" class="headerlink" title="4.3 混合密码系统的解密过程"></a>4.3 混合密码系统的解密过程</h4><p><img src="./images/图解密码技术总结/4.2.png" alt=""></p>
<p>===<br>认证部分</p>
<p>===</p>
<h3 id="五-单向散列函数-—-获取消息的“指纹”"><a href="#五-单向散列函数-—-获取消息的“指纹”" class="headerlink" title="五. 单向散列函数 — 获取消息的“指纹”"></a>五. 单向散列函数 — 获取消息的“指纹”</h3><h4 id="5-1-什么是单向散列值（one-way-hash-function）"><a href="#5-1-什么是单向散列值（one-way-hash-function）" class="headerlink" title="5.1 什么是单向散列值（one-way hash function）"></a>5.1 什么是单向散列值（one-way hash function）</h4><ul>
<li>单向散列函数可以根据消息的内容计算出<strong>固定长度</strong>的散列值，用于验证消息的<strong>完整性</strong>。</li>
</ul>
<h4 id="5-2-单向散列函数的性质"><a href="#5-2-单向散列函数的性质" class="headerlink" title="5.2 单向散列函数的性质"></a>5.2 单向散列函数的性质</h4><ul>
<li>根据任意长度的消息计算出固定长度的散列值。</li>
<li>能够<strong>快速</strong>计算出散列值。</li>
<li>消息不同散列值不同。<ul>
<li><strong>弱</strong>抗碰撞性：要找到和该条消息具有相同散列值的另一条消息是非常困难的。</li>
<li><strong>强</strong>抗碰撞性：要找到散列值相同的两条不同的消息是非常困难的。</li>
</ul>
</li>
<li>具备单向性</li>
</ul>
<h4 id="5-3-单向散列函数的实际应用"><a href="#5-3-单向散列函数的实际应用" class="headerlink" title="5.3 单向散列函数的实际应用"></a>5.3 单向散列函数的实际应用</h4><ol>
<li><strong>检测软件是否被篡改</strong></li>
<li><strong>基于口令的加密</strong>（Password Based Encryption，PBE）：将口令和盐（salt，通过伪随机数生成器产生的随机值）混合后计算其散列值，然后将这个散列值用作加密的密钥。这样做可以防御针对口令的字典攻击。</li>
<li><strong>消息认证码</strong>：消息认证码是将“发送者和接受者之间的共享密钥”和“消息”进行混合计算出的散列值。使用消息认证码可以检测并防止通信过程中的错误、篡改以及伪装。</li>
<li><strong>数字签名</strong>：数字签名一般是通过单向散列函数计算出消息的散列值，然后在这个散列值上施加数字签名。</li>
<li><strong>伪随机数生成器</strong></li>
<li><strong>一次性口令</strong>：常被用于服务器对客户端的合法性认证。</li>
</ol>
<h4 id="5-4-单向散列函数的具体例子"><a href="#5-4-单向散列函数的具体例子" class="headerlink" title="5.4 单向散列函数的具体例子"></a>5.4 单向散列函数的具体例子</h4><ol>
<li>MD4、MD5</li>
<li>SHA-1、SHA-256、SHA-384、SHA-512</li>
<li>RIPEMD-160</li>
</ol>
<p>===</p>
<h3 id="六-消息认证码-—-消息被正确传送了吗"><a href="#六-消息认证码-—-消息被正确传送了吗" class="headerlink" title="六. 消息认证码 — 消息被正确传送了吗"></a>六. 消息认证码 — 消息被正确传送了吗</h3><h4 id="6-1-什么是消息认证码"><a href="#6-1-什么是消息认证码" class="headerlink" title="6.1 什么是消息认证码"></a>6.1 什么是消息认证码</h4><ul>
<li>消息认证码（message authentication code）是一种确认完整性并进行认证的技术，取三个单词的首字母，简称MAC。</li>
<li>消息认证码是输入包括任意长度的消息和一个发送者和接收者之间共享的密钥，它可以输出固定长度的数据，这个数据成为MAC值。</li>
<li>消息认证码是一种与密钥相关的单向散列函数。如下图</li>
</ul>
<p><img src="./images/图解密码技术总结/6.1.png" alt=""></p>
<h4 id="6-2-消息认证码的使用步骤图"><a href="#6-2-消息认证码的使用步骤图" class="headerlink" title="6.2 消息认证码的使用步骤图"></a>6.2 消息认证码的使用步骤图</h4><p><img src="./images/图解密码技术总结/6.2.png" alt=""></p>
<h4 id="6-3-消息认证码的密钥的配送问题"><a href="#6-3-消息认证码的密钥的配送问题" class="headerlink" title="6.3 消息认证码的密钥的配送问题"></a>6.3 消息认证码的密钥的配送问题</h4><p>看上图就知道，共享密钥的配送问题依旧存在。解决方法也和对称密码差不多，例如公钥密码，Diffie-Hellman密钥交换等，具体项目具体安排。</p>
<h4 id="6-4-消息认证码的应用实例"><a href="#6-4-消息认证码的应用实例" class="headerlink" title="6.4 消息认证码的应用实例"></a>6.4 消息认证码的应用实例</h4><ol>
<li>SWIFT</li>
<li>IPsec</li>
<li>SSL/TLS</li>
</ol>
<h4 id="6-5-对消息认证码的攻击"><a href="#6-5-对消息认证码的攻击" class="headerlink" title="6.5 对消息认证码的攻击"></a>6.5 对消息认证码的攻击</h4><ol>
<li>重放攻击</li>
<li>密钥推测攻击</li>
</ol>
<h4 id="6-6-消息认证码无法解决的问题"><a href="#6-6-消息认证码无法解决的问题" class="headerlink" title="6.6 消息认证码无法解决的问题"></a>6.6 消息认证码无法解决的问题</h4><ol>
<li>对第三方证明。第三方无法知道消息来自A,B哪一方。（数字签名可以证明）</li>
<li>防止否认。（数字签名可以防止否认）</li>
</ol>
<p>===</p>
<h3 id="七-数字签名-—-消息到底是谁写的"><a href="#七-数字签名-—-消息到底是谁写的" class="headerlink" title="七. 数字签名 — 消息到底是谁写的"></a>七. 数字签名 — 消息到底是谁写的</h3><ul>
<li>数字签名可以识别篡改和伪装，还可以防止否认。</li>
<li>数字签名可以看成是公钥密码的<strong>反用</strong>，如图</li>
</ul>
<p>公钥密码与数字签名的密钥使用方式<br><img src="./images/图解密码技术总结/7.1.png" alt=""> </p>
<p>公钥密码<br><img src="./images/图解密码技术总结/7.2.png" alt=""> </p>
<p>数字签名<br><img src="./images/图解密码技术总结/7.3.png" alt=""> </p>
<h4 id="7-1-数字签名的方法"><a href="#7-1-数字签名的方法" class="headerlink" title="7.1 数字签名的方法"></a>7.1 数字签名的方法</h4><ul>
<li>直接对消息签名的方法</li>
<li>对消息的散列值签名的方法（常用）</li>
</ul>
<h4 id="7-2-实际应用"><a href="#7-2-实际应用" class="headerlink" title="7.2 实际应用"></a>7.2 实际应用</h4><ol>
<li>安全信息公告：一些信息安全方面的组织会在其网站上发布一些安全漏洞的警告，那么如何验证这些警告信息真的是这个组织发布的呢？此时就可以用数字签名。</li>
<li>软件下载</li>
<li>公钥证书：用于验证公钥的合法性。</li>
<li>SSL/TLS</li>
</ol>
<h4 id="7-3-通过RSA实现数字签名"><a href="#7-3-通过RSA实现数字签名" class="headerlink" title="7.3 通过RSA实现数字签名"></a>7.3 通过RSA实现数字签名</h4><ul>
<li>签名 = 消息 D MOD N (消息的D次方除以N取余数)</li>
<li>由签名求得的消息 = 签名 E MOD N （签名的E次方除以N取余数）</li>
<li>D和N就是签名者的私钥</li>
<li>E和N就是签名者的公钥</li>
</ul>
<h4 id="7-4-对数字签名的攻击"><a href="#7-4-对数字签名的攻击" class="headerlink" title="7.4 对数字签名的攻击"></a>7.4 对数字签名的攻击</h4><ol>
<li>中间人攻击。（可以通过公钥证书来防止）</li>
<li>对单向散列函数的攻击</li>
<li>利用数字签名攻击公钥密码</li>
</ol>
<h4 id="7-5-各类密码技术的对比"><a href="#7-5-各类密码技术的对比" class="headerlink" title="7.5 各类密码技术的对比"></a>7.5 各类密码技术的对比</h4><p><img src="./images/图解密码技术总结/7.4.png" alt=""> </p>
<p>===</p>
<h3 id="八-证书-—-为公钥加上数字签名"><a href="#八-证书-—-为公钥加上数字签名" class="headerlink" title="八 证书 — 为公钥加上数字签名"></a>八 证书 — 为公钥加上数字签名</h3><h4 id="8-1-什么是证书"><a href="#8-1-什么是证书" class="headerlink" title="8.1 什么是证书"></a>8.1 什么是证书</h4><p>公钥证书（Public-Key Certificae，PKC）：里面记有姓名、组织、邮箱地址等个人信息，以及属于此人的<strong>公钥</strong>，并由<strong>认证机构</strong>（Certification Authority、Certifying Authority， CA）施加数字签名。只要看到公钥证书，我们就可以知道认证机构认定该公钥的确属于此人。公钥证书简称为证书（certificate）</p>
<h4 id="8-2-证书的应用场景"><a href="#8-2-证书的应用场景" class="headerlink" title="8.2 证书的应用场景"></a>8.2 证书的应用场景</h4><p><img src="./images/图解密码技术总结/8.1.png" alt=""> </p>
<h4 id="8-3-公钥基础设施（PKI）"><a href="#8-3-公钥基础设施（PKI）" class="headerlink" title="8.3 公钥基础设施（PKI）"></a>8.3 公钥基础设施（PKI）</h4><p>就是为了能够更有效的运用公钥而制定的一系列规范和规格的总称。</p>
<p>组成要素：</p>
<ul>
<li>用户 — 使用PKI的人</li>
<li>认证机构 — 颁发证书的人</li>
<li>仓库 — 保存证书的数据库</li>
</ul>
<p>===</p>
<h3 id="九-随机数-—-不可预测性的源泉"><a href="#九-随机数-—-不可预测性的源泉" class="headerlink" title="九 随机数 — 不可预测性的源泉"></a>九 随机数 — 不可预测性的源泉</h3><h4 id="9-1-随机数的性质"><a href="#9-1-随机数的性质" class="headerlink" title="9.1 随机数的性质"></a>9.1 随机数的性质</h4><ul>
<li>随机性 — 不存在统计学偏差，是完全杂乱的数列。（弱伪随机数）</li>
<li>不可预测性 — 不能从过去的数列推测出下一个出现的数。（强伪随机数）</li>
<li><p>不可重现性 — 除非将数列本身保存下来，否则不能重现相同的数列。（真随机数）</p>
<p>  上面三种性质中，越往下越严格。</p>
</li>
</ul>
<p><img src="./images/图解密码技术总结/9.1.png" alt=""> </p>
<ul>
<li>对于软件所生成的数列，周期必定是有限的。凡是有限周期的数列，都不具备不可重现性。</li>
<li>要生成不可重现的随机书里额，需要从不可重现的物理现象中获取信息。</li>
</ul>
<p>===</p>
<h3 id="十-SSL-TLS-—-为了更安全的通信"><a href="#十-SSL-TLS-—-为了更安全的通信" class="headerlink" title="十 SSL/TLS — 为了更安全的通信"></a>十 SSL/TLS — 为了更安全的通信</h3><h4 id="10-1-什么是SSL-TLS"><a href="#10-1-什么是SSL-TLS" class="headerlink" title="10.1 什么是SSL/TLS"></a>10.1 什么是SSL/TLS</h4><ul>
<li>是目前世界上最广泛的密码通信方法。</li>
<li>综合运用了前面提到的技术：对称密码、消息认证码、公钥密码、数字签名、伪随机数生成器等密码技术。</li>
</ul>
<p>===</p>
<h3 id="十一-密码技术与现实社会"><a href="#十一-密码技术与现实社会" class="headerlink" title="十一 密码技术与现实社会"></a>十一 密码技术与现实社会</h3><h4 id="11-1-密码学家的工具箱"><a href="#11-1-密码学家的工具箱" class="headerlink" title="11.1 密码学家的工具箱"></a>11.1 密码学家的工具箱</h4><p><img src="./images/图解密码技术总结/11.1.png" alt=""></p>
<h4 id="11-2-密码技术与压缩技术"><a href="#11-2-密码技术与压缩技术" class="headerlink" title="11.2 密码技术与压缩技术"></a>11.2 密码技术与压缩技术</h4><p><img src="./images/图解密码技术总结/11.2.png" alt=""></p>
<ul>
<li>密钥是机密性的精华</li>
<li>散列值是完整性的精华</li>
<li>认证符号（MAC值和签名）是认证的精华</li>
<li>种子是不可预测性的精华</li>
</ul>
<p><img src="./images/图解密码技术总结/11.3.png" alt=""></p>
<h4 id="11-3-只有完美的密码，没有完美的人"><a href="#11-3-只有完美的密码，没有完美的人" class="headerlink" title="11.3 只有完美的密码，没有完美的人"></a>11.3 只有完美的密码，没有完美的人</h4>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;《图解密码技术》总结&quot;&gt;&lt;a href=&quot;#《图解密码技术》总结&quot; class=&quot;headerlink&quot; title=&quot;《图解密码技术》总结&quot;&gt;&lt;/a&gt;《图解密码技术》总结&lt;/h1&gt;&lt;h3 id=&quot;一-历史上的密码&quot;&gt;&lt;a href=&quot;#一-历史上的密码&quot; cla
    
    </summary>
    
      <category term="书" scheme="https://fenglai0802.github.io/categories/%E4%B9%A6/"/>
    
    
      <category term="密码" scheme="https://fenglai0802.github.io/tags/%E5%AF%86%E7%A0%81/"/>
    
      <category term="SSL" scheme="https://fenglai0802.github.io/tags/SSL/"/>
    
  </entry>
  
  <entry>
    <title>不同unicode编码的空格挖的坑</title>
    <link href="https://fenglai0802.github.io/2016/08/04/%E4%B8%8D%E5%90%8Cunicode%E7%BC%96%E7%A0%81%E7%9A%84%E7%A9%BA%E6%A0%BC%E6%8C%96%E7%9A%84%E5%9D%91/"/>
    <id>https://fenglai0802.github.io/2016/08/04/不同unicode编码的空格挖的坑/</id>
    <published>2016-08-04T09:33:14.000Z</published>
    <updated>2016-08-28T07:35:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间在做搜索的时候，遇到一个关于空格的小问题，总结一下。</p>
<p>有时在文本值中会插入一些空格字符 （Unicode 字符集值 32 和 160） ，比如说标题之类的。当你对包含空格的值进行<strong>排序、 筛选或搜索</strong>时，这些字符有时会导致意外的结果。本次就是因为把数据存放在dom节点上，取出来做搜索的时候，发现编码发现了改变（从32变成了160），导致无法正确匹配。</p>
<blockquote>
<p>The non-breaking space (U+00A0 Unicode, 160 decimal, &nbsp;) is not the same as the space character (U+0020 Unicode, 32 decimal). Well, both of them seems to be a “space”, but they are absolutely different characters.</p>
</blockquote>
<p>这里的解决方案是：采用正则替换成统一字符，如下</p>
<pre><code>var s = &apos; &apos; // 假设这里是一个160的空格。
var reg = new RegExp(String.fromCharCode(160),&quot;gm&quot;);
var 32sp = String.fromCharCode(32)
s = s.replace(reg, 32sp);
</code></pre><p>后来重构代码，直接废除了将数据存在dom上这种方案，就更好了。</p>
<p>除了空格字符，非打印字符在进行<strong>排序、 筛选或搜索</strong>操作时，也可能会遇到这类问题，<a href="https://support.office.com/zh-cn/article/%E5%88%A0%E9%99%A4%E6%96%87%E6%9C%AC%E4%B8%AD%E7%9A%84%E7%A9%BA%E6%A0%BC%E5%92%8C%E9%9D%9E%E6%89%93%E5%8D%B0%E5%AD%97%E7%AC%A6-023f3a08-3d56-49e4-bf0c-fe5303222c9d" target="_blank" rel="external">参考</a>。要注意~</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前段时间在做搜索的时候，遇到一个关于空格的小问题，总结一下。&lt;/p&gt;
&lt;p&gt;有时在文本值中会插入一些空格字符 （Unicode 字符集值 32 和 160） ，比如说标题之类的。当你对包含空格的值进行&lt;strong&gt;排序、 筛选或搜索&lt;/strong&gt;时，这些字符有时会导致
    
    </summary>
    
      <category term="JS" scheme="https://fenglai0802.github.io/categories/JS/"/>
    
    
      <category term="空白字符" scheme="https://fenglai0802.github.io/tags/%E7%A9%BA%E7%99%BD%E5%AD%97%E7%AC%A6/"/>
    
      <category term="编码" scheme="https://fenglai0802.github.io/tags/%E7%BC%96%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>鼠标跟随旋转效果实现</title>
    <link href="https://fenglai0802.github.io/2016/08/04/%E9%BC%A0%E6%A0%87%E8%B7%9F%E9%9A%8F%E6%97%8B%E8%BD%AC%E6%95%88%E6%9E%9C%E5%AE%9E%E7%8E%B0/"/>
    <id>https://fenglai0802.github.io/2016/08/04/鼠标跟随旋转效果实现/</id>
    <published>2016-08-03T16:30:11.000Z</published>
    <updated>2017-03-10T08:50:13.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="鼠标跟随的3D转动"><a href="#鼠标跟随的3D转动" class="headerlink" title="鼠标跟随的3D转动"></a>鼠标跟随的3D转动</h3><p>首先，甩一枚简单的<a href="http://runjs.cn/detail/1hnseaw3" target="_blank" rel="external">demo</a>看下要实现的效果。点击右下角可查看源码。</p>
<p>ok，直接开干，这个demo里面主要用到了两个属性：<code>transform</code>和<code>perspective</code>。分别可以设置3D和透视投影的效果。</p>
<h3 id="3D变换效果"><a href="#3D变换效果" class="headerlink" title="3D变换效果"></a>3D变换效果</h3><p>首先介绍下<code>transform</code>，写过一丢丢动画的孩子都会接触过的属性。<code>CSS3</code>的3D效果是使用<code>transform</code>的<code>rotateX(Y, Z)</code>，<code>translateX(Y, Z)</code>，<code>scaleX(Y, Z)</code>方法进行设置的。</p>
<p><img src="./images/3D转动/1.jpg" alt=""></p>
<p>上图就是一个3D坐标系，需要注意的是，3D元素的原点应该是在元素的中心，而不是像上图一样在立方体的一个角上。如果只是单单一个元素的话，它的形状就是一个平面区域。下面简单介绍一下<code>transform</code>中相关的3D方法。</p>
<h5 id="rotateX-Y-Z"><a href="#rotateX-Y-Z" class="headerlink" title="rotateX(Y, Z)"></a>rotateX(Y, Z)</h5><p>顾名思义就是绕着X轴（Y轴或者Z轴）旋转。注意：<strong>逆时针为正方向</strong>（如图）</p>
<h5 id="translateX-Y-Z"><a href="#translateX-Y-Z" class="headerlink" title="translateX(Y, Z)"></a>translateX(Y, Z)</h5><p>默认情况下，开启的是平面投影，所以此时设置<code>translateZ</code>是没有什么luan用的。那怎么生效呢，看下去才告诉你（╭(╯^╰)╮）。</p>
<h5 id="scaleX-Y-Z"><a href="#scaleX-Y-Z" class="headerlink" title="scaleX(Y, Z)"></a>scaleX(Y, Z)</h5><p>缩放，好理解。偶尔会用来做字号的特殊处理，比如像chrome默认的最小字号是<code>12px</code>，要是你家视觉非要设置<code>10px</code>大小的字体咋整，那就给他一巴掌，叫他要求这么多（现实情况是可以用这个属性来解决……）。</p>
<p>题外话：chrome的默认最小字号可以在设置中更改，不过你的用户可不管这些。</p>
<hr>
<h5 id="transform-style属性"><a href="#transform-style属性" class="headerlink" title="transform-style属性"></a>transform-style属性</h5><p>它有两个值：</p>
<ul>
<li><code>flat</code>(默认，顾名思义就是平面状态，所以上面说的设置translateZ才会失效。)</li>
<li><code>preserve-3d</code></li>
</ul>
<p>聪明如你马上明白<code>preserve-3d</code>才是主角，设置了<code>transform-style: preserve-3d</code>的父元素会生成一个3D空间，把所有的<strong>子元素</strong>都包括在这个3D空间内。</p>
<p><strong>注意</strong>：上面说的是<strong>子元素</strong> ，不是<strong>后代元素</strong>，看看demo中的<code>我是preserve-3d的孙子</code>这行字所在的元素，Z值和它爸爸<code>黑月</code>是不同的，但是转动卡片发现，视觉效果上他们是在同一个Z值平面的。那要让孙子上的Z值也生效呢？啥，你还不知道！那你再看一遍上面的两段话- -。（答案：在<code>黑月</code>上再设置一次这个属性，可以在demo上尝试修改下看看）。</p>
<p>对于父元素设置的<code>transform</code>属性，都会应用到生成的这个3D空间，对整个空间进行3D操作（旋转，平移，缩放）。最后会把所有的元素投影到<code>屏幕</code>上，不是父元素上！</p>
<p>当<code>transform-style</code>的值为<code>flat</code>时，子元素和父元素是互相独立的，并没有在父元素的3D空间内，他们各自做各自的3D变换，然后<strong>按照先后顺序</strong>投影到父元素上。这也是<code>flat</code>时，translateZ失效的原因。</p>
<p><strong>tips</strong>：设置在transform属性上的<code>rotateX(Y, Z)</code>，<code>translateX(Y, Z)</code>，<code>scaleX(Y, Z)</code>方法是从右向左执行的。</p>
<hr>
<h3 id="透视投影"><a href="#透视投影" class="headerlink" title="透视投影"></a>透视投影</h3><p>透视投影是模拟人眼的图像观察方式，让平面上的物体呈现现实的视觉效果。</p>
<p>有两种设置方式：</p>
<ul>
<li><code>perspective: none | &lt;length&gt;;</code></li>
<li><code>transform: perspective(&lt;length&gt;) method(p) method(p) ...;</code></li>
</ul>
<p>第一种：可以将<strong>子元素</strong>(不包含自身，不包括后代元素)的投影效果设置为透视投影。<br>第二种：为这个元素自身开启透视投影模式。</p>
<p>先看下<strong>3D视角</strong>的原理图，来自<a href="https://css-tricks.com/tour-performant-responsive-css-site/" target="_blank" rel="external">这里</a></p>
<p><img src="./images/3D转动/2.png" alt=""></p>
<p>图中淡蓝色部分即电脑屏幕所在的平面（z=0的平面），眼睛所在的位置就是通过<code>perspective</code>设置的模拟焦点位置，焦点到z=0平面的距离就是<code>perspective</code>的值，而橘红色部分就是设置了<code>translateZ</code>为负值的3D元素的所在平面，3D元素到z=0平面的距离就是3D元素上<code>translateZ</code>的值，如图为负值，如果在焦点和z=0及平面之间，则为正值。</p>
<p>这是透视的<strong>平面</strong>原理图，来自<a href="https://segmentfault.com/a/1190000003843764" target="_blank" rel="external">这里</a>。<br><img src="./images/3D转动/3.png" alt=""></p>
<p>通过这两张图，应该能够很直观的看出<code>perspective</code>和<code>translateZ</code>的设置对于3D元素在屏幕上产生的投影的效果了。当元素的z值大于’perspective’的值时，你就看不见它了，就像你的boss站在你的脑袋后面一样一样。一般情况下，’perspective’设置500px到1000px在视觉上比较合理。</p>
<p>在<a href="http://runjs.cn/detail/1hnseaw3" target="_blank" rel="external">demo</a>中，如果取消<code>perspective</code>透视属性，你会发现，卡片就像一个没固定好的相框在转动，这就算是透视属性的必要性。</p>
<p>透视投影还可以设置焦点的位置（默认在中心），因为你的脑袋也是可以动的：</p>
<p><code>perspective-origin: x y;</code></p>
<p><strong>到这里，3d和透视投影的相关属性就介绍完了，有什么不清楚的你可以改改<a href="http://runjs.cn/detail/1hnseaw3" target="_blank" rel="external">demo</a>测试下。</strong></p>
<p>对不起，还没完……</p>
<hr>
<h3 id="鼠标跟随的实现"><a href="#鼠标跟随的实现" class="headerlink" title="鼠标跟随的实现"></a>鼠标跟随的实现</h3><p>关键是理清前面的属性，最后的鼠标跟随转动效果通过js实现应该比较简单了，监听<code>mousemove</code>事件，根据鼠标位置到3D元素的中心的<code>距离</code>，<code>除以</code>一定的<code>系数</code>，实时改变元素的<code>rotateX</code>和<code>rotateY</code>的值来达到效果。你可以通过改变<code>系数</code>的大小来控制<code>转动的灵敏度</code>。</p>
<p>贴一下代码：</p>
<pre><code>var o = $(&quot;#card&quot;);
$(&quot;#top&quot;).on(&quot;mousemove&quot;, function(t) {
    var e = -($(window).innerWidth() / 2 - t.pageX) / 20,
        n = ($(window).innerHeight() / 2 - t.pageY) / 10;
    o.attr(&quot;style&quot;,
        &quot;transform: rotateY(&quot; + e + &quot;deg) rotateX(&quot; + n + &quot;deg);
        -webkit-transform: rotateY(&quot; + e + &quot;deg) rotateX(&quot; + n + &quot;deg);
        -moz-transform: rotateY(&quot; + e + &quot;deg) rotateX(&quot; + n + &quot;deg)&quot;
    )
})
</code></pre><hr>
<p><strong> THE END……能看到这里的人真是让俺感动啊~</strong></p>
<p>养成好习惯，顺手打广告：这个动效用在了<a href="https://youdata.netease.com/" target="_blank" rel="external">网易有数</a>的首页。<strong>网易有数</strong>是一款敏捷数据分析平台，欢迎使用体验。</p>
<p>参考自：</p>
<ul>
<li><a href="https://css-tricks.com/tour-performant-responsive-css-site/" target="_blank" rel="external">Tour of a Performant and Responsive CSS Only Site</a></li>
<li><a href="https://segmentfault.com/a/1190000003843764" target="_blank" rel="external">3D效果 &amp; 透视</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;鼠标跟随的3D转动&quot;&gt;&lt;a href=&quot;#鼠标跟随的3D转动&quot; class=&quot;headerlink&quot; title=&quot;鼠标跟随的3D转动&quot;&gt;&lt;/a&gt;鼠标跟随的3D转动&lt;/h3&gt;&lt;p&gt;首先，甩一枚简单的&lt;a href=&quot;http://runjs.cn/detail/1
    
    </summary>
    
      <category term="CSS" scheme="https://fenglai0802.github.io/categories/CSS/"/>
    
    
      <category term="3d" scheme="https://fenglai0802.github.io/tags/3d/"/>
    
      <category term="转动" scheme="https://fenglai0802.github.io/tags/%E8%BD%AC%E5%8A%A8/"/>
    
  </entry>
  
  <entry>
    <title>Hexo + GitHub Pages 构建博客</title>
    <link href="https://fenglai0802.github.io/2016/08/03/Hexo-GitHub-Pages-%E6%9E%84%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>https://fenglai0802.github.io/2016/08/03/Hexo-GitHub-Pages-构建博客/</id>
    <published>2016-08-03T04:54:27.000Z</published>
    <updated>2016-08-04T02:34:53.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-介绍篇"><a href="#1-介绍篇" class="headerlink" title="1. 介绍篇"></a>1. 介绍篇</h2><p><a href="https://fenglai0802.github.io/">DEMO</a></p>
<h4 id="什么是Hexo"><a href="#什么是Hexo" class="headerlink" title="什么是Hexo"></a>什么是Hexo</h4><p><a href="https://hexo.io/" target="_blank" rel="external">Hexo</a> 是一个简单地、轻量地、基于Node的一个静态博客框架，可以方便的生成静态网页。作者是台湾大学生tommy351。</p>
<h4 id="什么是GitHub-Pages"><a href="#什么是GitHub-Pages" class="headerlink" title="什么是GitHub Pages"></a>什么是GitHub Pages</h4><p><a href="https://pages.github.com/" target="_blank" rel="external">GitHub Pages</a> 可以被认为是用户编写的、托管在github上的静态网页。由于它的空间免费稳定， 可以用于介绍托管在github上的Project或者搭建网站。有两种形式: Project Site 和 User/Org Site。</p>
<p>GitHub Pages 生成的网站的默认域名是 username.github.io 或者 username.github.io/project-name ，但GitHub Pages是支持自定义域名的，参考教程：<a href="https://www.zhihu.com/question/31377141" target="_blank" rel="external">github怎么绑定自己的域名</a></p>
<h2 id="2-安装篇"><a href="#2-安装篇" class="headerlink" title="2. 安装篇"></a>2. 安装篇</h2><h4 id="安装中的一些小问题提醒"><a href="#安装中的一些小问题提醒" class="headerlink" title="安装中的一些小问题提醒"></a>安装中的一些小问题提醒</h4><ol>
<li>npm 报连接错误导致的安装失败：建议使用<a href="http://npm.taobao.org/" target="_blank" rel="external">淘宝NPM镜像</a>。</li>
<li>权限错误：命令前加sudo</li>
</ol>
<h4 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h4><ul>
<li>安装node (建议采用<a href="https://fenglai0802.github.io/2016/08/03/%E5%88%A9%E7%94%A8%E6%A8%A1%E5%9D%97n%E7%AE%A1%E7%90%86node%E7%89%88%E6%9C%AC/">n模块安装</a>)</li>
<li>安装git（安装Xcode自带）</li>
<li>申请github账号</li>
</ul>
<h4 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h4><ol>
<li><p>首先全局安装hexo</p>
<pre><code>$ npm install -g hexo
</code></pre></li>
</ol>
<ol>
<li><p>创建工作文件夹，举例命名为<code>blog</code>;</p>
</li>
<li><p>进入<code>blog</code>，初始化：</p>
<pre><code>$ hexo init
</code></pre></li>
</ol>
<p>这里可能出现初始化错误，原因就是默认的npm出现连接错误，你需要手动执行<code>$ cnpm install</code>。<br>cnpm就是淘宝镜像的命令。</p>
<ol>
<li><p>安装server，用于本地调试：</p>
<pre><code>$ cnpm install hexo-server --save
</code></pre></li>
</ol>
<p>如果不安装，现在的版本是不在带服务器的，导致后面执行<code>hexo server</code>报没有命令的错误。</p>
<ol>
<li><p>生成静态页面：</p>
<pre><code>$ hexo generate 或 $ hexo g
</code></pre></li>
<li><p>启动本地服务，进行文章预览调试：</p>
<pre><code>$ $hexo server或 $ hexo s。
</code></pre></li>
</ol>
<p>启动成功，根据提示在浏览器浏览器输入 <a href="http://localhost:4000" target="_blank" rel="external">http://localhost:4000</a> 即可查看。</p>
<h4 id="hexo一些常用命令-可以通过hexo-help查看-："><a href="#hexo一些常用命令-可以通过hexo-help查看-：" class="headerlink" title="hexo一些常用命令(可以通过hexo help查看)："></a>hexo一些常用命令(可以通过<code>hexo help</code>查看)：</h4><ul>
<li><p><code>hexo new &quot;postName&quot;</code> #新建文章</p>
</li>
<li><p><code>hexo new page &quot;pageName&quot;</code> #新建页面</p>
</li>
<li><p><code>hexo generate</code> #生成静态页面至public目录</p>
</li>
<li><p><code>hexo server</code> #开启预览访问端口（默认端口4000，’ctrl + c’关闭server）</p>
</li>
<li><p><code>hexo deploy</code> #将.deploy目录部署到GitHub</p>
</li>
<li><p><code>hexo help</code> # 查看帮助</p>
</li>
<li><p><code>hexo version</code> #查看Hexo的版本</p>
</li>
</ul>
<h4 id="hexo关联配置Github"><a href="#hexo关联配置Github" class="headerlink" title="hexo关联配置Github"></a>hexo关联配置Github</h4><ul>
<li><p>关联之前，你得先创建好自己的<a href="https://pages.github.com/" target="_blank" rel="external">GitHub Pages</a>，按着官方教程一步步来，或者自己google。</p>
</li>
<li><p>修改<code>blog</code>下的配置文件<code>_config.xml</code>:（repo的地址写你自己的GitHub Pages项目地址啊）</p>
<pre><code>deploy:

     type: git

     repo: https://github.com/fenglai0802/fenglai0802.github.io.git

    branch: master
</code></pre></li>
<li><p>安装发布命令：</p>
<pre><code>$ cnpm install hexo-deployer-git --save
</code></pre></li>
<li><p>执行命名：</p>
<pre><code>$ hexo deploy
</code></pre></li>
</ul>
<p>此时public文件夹下的内容就会被上传到你的github中fenglai0802.github.io的这个项目下。</p>
<ul>
<li><p>然后再浏览器中输入 <a href="https://fenglai0802.github.io/">https://fenglai0802.github.io/</a> 就可以查看了。</p>
</li>
<li><p>每次部署的步骤，可按以下三步来进行。(建议自己写一个shell方便发布)</p>
<pre><code>$ hexo clean

$ hexo generate

$ hexo deploy
</code></pre></li>
</ul>
<h2 id="3-hexo主题篇"><a href="#3-hexo主题篇" class="headerlink" title="3. hexo主题篇"></a>3. hexo主题篇</h2><ul>
<li><a href="https://github.com/hexojs/hexo/wiki/Themes" target="_blank" rel="external">主题汇总</a>。使用方法里面也有介绍，简单讲就是把主题克隆到theme文件夹，然后修改_config.yml配置文件中的theme选项就行。</li>
<li>这里比较推荐主题<a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="external">NexT</a>。自用就是这个，哈哈~</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-介绍篇&quot;&gt;&lt;a href=&quot;#1-介绍篇&quot; class=&quot;headerlink&quot; title=&quot;1. 介绍篇&quot;&gt;&lt;/a&gt;1. 介绍篇&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://fenglai0802.github.io/&quot;&gt;DEMO&lt;/a&gt;&lt;/p&gt;
&lt;h
    
    </summary>
    
      <category term="常规" scheme="https://fenglai0802.github.io/categories/%E5%B8%B8%E8%A7%84/"/>
    
    
      <category term="hexo" scheme="https://fenglai0802.github.io/tags/hexo/"/>
    
      <category term="github" scheme="https://fenglai0802.github.io/tags/github/"/>
    
      <category term="博客" scheme="https://fenglai0802.github.io/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>利用模块n管理node版本</title>
    <link href="https://fenglai0802.github.io/2016/08/03/%E5%88%A9%E7%94%A8%E6%A8%A1%E5%9D%97n%E7%AE%A1%E7%90%86node%E7%89%88%E6%9C%AC/"/>
    <id>https://fenglai0802.github.io/2016/08/03/利用模块n管理node版本/</id>
    <published>2016-08-03T02:44:47.000Z</published>
    <updated>2016-08-04T02:35:02.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="利用模块n管理node版本"><a href="#利用模块n管理node版本" class="headerlink" title="利用模块n管理node版本"></a>利用模块n管理node版本</h3><ul>
<li>由于node的版本迭代速度非常快，所以版本多样，所以升级版本或者切换版本都比较麻烦。本文介绍一下模块n的好处。</li>
</ul>
<h5 id="n"><a href="#n" class="headerlink" title="n"></a>n</h5><ul>
<li><p>n是node的一个模块，作者是TJ Holowaychuk（鼎鼎大名的Express框架作者），就像它的名字一样，它的理念就是简单：</p>
<blockquote>
<p>no subshells, no profile setup, no convoluted api, just simple</p>
</blockquote>
</li>
<li><p>安装n</p>
<pre><code>$ sudo npm install -g n
</code></pre></li>
<li><p>安装完成之后，直接输入n后控制台就会输出当前已安装的node版本以及正在使用的版本（前面有个o的），通过上下方向键来选择想要使用的版本，回车生效。</p>
<pre><code>$ n
    0.10.1
o   6.0.0
</code></pre></li>
<li><p>安装指定版本node</p>
<pre><code>$ n 6.0.0
</code></pre></li>
<li><p>安装最新版本node</p>
<pre><code>$ n latest
</code></pre></li>
<li><p>安装稳定版本node</p>
<pre><code>$ n stable
</code></pre></li>
<li><p>删除某个版本</p>
<pre><code>$ n rm 0.10.1
</code></pre></li>
<li><p>以指定的版本来执行脚本</p>
<pre><code>$ n use 0.10.21 some.js
</code></pre></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;利用模块n管理node版本&quot;&gt;&lt;a href=&quot;#利用模块n管理node版本&quot; class=&quot;headerlink&quot; title=&quot;利用模块n管理node版本&quot;&gt;&lt;/a&gt;利用模块n管理node版本&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;由于node的版本迭代速度非常快，所以版
    
    </summary>
    
      <category term="常规" scheme="https://fenglai0802.github.io/categories/%E5%B8%B8%E8%A7%84/"/>
    
    
      <category term="node版本" scheme="https://fenglai0802.github.io/tags/node%E7%89%88%E6%9C%AC/"/>
    
  </entry>
  
</feed>
