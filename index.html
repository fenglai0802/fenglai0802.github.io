<!doctype html>



  


<html class="theme-next muse use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="黑月的BLooooog" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.2" />






<meta property="og:type" content="website">
<meta property="og:title" content="黑月的BLooooog">
<meta property="og:url" content="https://fenglai0802.github.io/index.html">
<meta property="og:site_name" content="黑月的BLooooog">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="黑月的BLooooog">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="https://fenglai0802.github.io/"/>


  <title> 黑月的BLooooog </title>
</head>

<body itemscope itemtype="//schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="//schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">黑月的BLooooog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/01/Web-Audo-API-advance/" itemprop="url">
                  Web Audo API advance
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-03-01T19:36:03+08:00" content="2017-03-01">
              2017-03-01
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Web-Audio-API-Advance"><a href="#Web-Audio-API-Advance" class="headerlink" title="Web Audio API Advance"></a>Web Audio API Advance</h2><p>一个简单的、典型的web audio工作流是这样的：</p>
<ol>
<li>创建音频环境对象（AudioContext）。</li>
<li>在音频环境对象AudioContext中，创建音源。例如<code>&lt;audio&gt;</code>，振荡器（oscillator），源。</li>
<li>创建效果节点（effectNode），例如分析、增益、混响、双二阶滤波器、平移、压缩等。</li>
<li>选择最终的音源目的地，例如你的系统扬声器。</li>
<li>连接源到效果节点，以及效果节点到输出终端。</li>
</ol>
<p><img src="./images/web_audio_api/1.png" alt=""></p>
<p>简单来说，<code>Web Audio API</code>提供了一个简单强大的机制来实现控制web应用程序的音频内容，但是<code>Web Audio API</code>并不会取代<code>&lt;audio&gt;</code>，而可以把它看做是<code>&lt;audio&gt;</code>的补充，就好像<code>&lt;img&gt;</code>和<code>&lt;canvas&gt;</code>的共存关系。你用来实现音频的方式取决于你的需求的复杂程度，如果只是简单的音轨播放，那么<code>&lt;audio&gt;</code>足够了。</p>
<p>这里首先来明确两个概念。</p>
<h3 id="1-AudioContext-–-音频环境对象"><a href="#1-AudioContext-–-音频环境对象" class="headerlink" title="1. AudioContext – 音频环境对象"></a>1. AudioContext – 音频环境对象</h3><p>W3C描述如下:</p>
<blockquote>
<p>This interface represents a set of AudioNode objects and their connections. It allows for arbitrary routing of signals to the AudioDestinationNode (what the user ultimately hears). Nodes are created from the context and are then connected together. In most use cases, only a single AudioContext is used per document.</p>
</blockquote>
<p>大致意思是这个接口是音频节点和节点之间连接关系的集合。他允许信号经过任意的路由连接到目的节点（音频播放设备节点）上。节点都是通过音频环境（AudioContext）创建的，然后连接在一起。在大多数情况下，一个文档只需要一个音频环境。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// 1.创建音频环境对象AudioContext；</span></div><div class="line"><span class="keyword">var</span> audioCtx = <span class="keyword">new</span> AudioContext();</div><div class="line"></div><div class="line"><span class="comment">// 2.创建音源节点</span></div><div class="line"><span class="keyword">var</span> sourceNode = audioCtx.createBufferSource();</div><div class="line"></div><div class="line"><span class="comment">// 3.创建效果节点</span></div><div class="line"><span class="comment">// 创建分析节点</span></div><div class="line"><span class="keyword">var</span> analyser = audioCtx.createAnalyser();</div><div class="line"><span class="comment">// 创建低阶滤波节点</span></div><div class="line"><span class="keyword">var</span> biquadFilter = audioCtx.createBiquadFilter();</div><div class="line"><span class="comment">// 创建增益节点</span></div><div class="line"><span class="keyword">var</span> gainNode = audioCtx.createGain();</div></pre></td></tr></table></figure>
<p>可以看出AudioContext相当于一个容器，各类音频节点，及节点间的连接方式都需要AudioContext的实例对象来创建。</p>
<h3 id="2-AudioNode-–-音频节点"><a href="#2-AudioNode-–-音频节点" class="headerlink" title="2. AudioNode – 音频节点"></a>2. AudioNode – 音频节点</h3><p>W3C中描述如下:</p>
<blockquote>
<p>AudioNodes are the building blocks of an AudioContext. This interface represents audio sources, the audio destination, and intermediate processing modules.</p>
</blockquote>
<p>音频节点是一个音频环境的基础模块。这些节点可以是音频源节点，音频播放设备节点，也可以是中间处理模块。</p>
<h3 id="3-Demo构建流程"><a href="#3-Demo构建流程" class="headerlink" title="3. Demo构建流程"></a>3. Demo构建流程</h3><p>先来看一个简单的音频模型，音频直接连接到播放设备节点播放。</p>
<p><img src="./images/web_audio_api/2.png" alt=""></p>
<p>再来看一套专业的音效合成处理图：</p>
<p><img src="./images/web_audio_api/3.png" alt=""></p>
<p>是不是很厉害，好，那么接下来我们讲点简单的……</p>
<h4 id="3-1-构建AudioContext对象"><a href="#3-1-构建AudioContext对象" class="headerlink" title="3.1 构建AudioContext对象"></a>3.1 构建AudioContext对象</h4><p>首先，需要构建一个AudioContext实例，来创建一个音频环境容器。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 1. 一个文档可以存在多个实例，但是没有必要，通常只需要一个。</span></div><div class="line"><span class="comment">// 2. 对于webkit/blink内核的浏览器需要加webkit前缀。</span></div><div class="line"><span class="comment">// 3. 在Safari浏览器中，如果不加window对象，会无效。</span></div><div class="line"><span class="comment">// 所以构建音频环境对象如下：</span></div><div class="line"><span class="keyword">var</span> audioCtx = <span class="keyword">new</span> (<span class="built_in">window</span>.AudioContext || <span class="built_in">window</span>.webkitAudioContext)();</div></pre></td></tr></table></figure>
<h4 id="3-2-创建音源AudioSource"><a href="#3-2-创建音源AudioSource" class="headerlink" title="3.2 创建音源AudioSource"></a>3.2 创建音源AudioSource</h4><p>现在有了环境的实例对象，前面也提到这个对象非常有用，接下来就是用这个实例整一个音源。音源可以用以下几种方式创建/获取：</p>
<ul>
<li>从PCM（Pulse Code Modulation，脉冲编码调制）数据构建：这个PCM数据是啥玩意，怎么来？简单的说：首先可以通过XMLHttpRequest获取被支持的音频格式的文件（比如x.mp3），然后利用AudioContext对象中的方法对文件进行解码后获得的数据。下文中提到的自产<a href="https://fenglai0802.github.io/demo/web_audio_api/simple.html">demo</a> ，就是利用这种方式获取音源的。AudioContext提供了解密被支持的音频格式的多种方法： <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/AudioContext/createBuffer" target="_blank" rel="external">AudioContext.createBuffer()</a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/AudioContext/createBufferSource" target="_blank" rel="external">AudioContext.createBufferSource()</a>, 以及 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/AudioContext/decodeAudioData" target="_blank" rel="external">AudioContext.decodeAudioData()</a>.</li>
<li>利用AudioContext对象直接生产音频节点，比如振荡器oscillator。具体API：<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/AudioContext/createOscillator" target="_blank" rel="external">AudioContext.createOscillator() </a></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> oscillator = audioCtx.createOscillator();</div></pre></td></tr></table></figure>
<ul>
<li>来自HTML音频元素，如我们熟悉的<code>&lt;video&gt;</code>或者<code>&lt;audio&gt;</code>.具体API: <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/AudioContext/createMediaElementSource" target="_blank" rel="external"> AudioContext.createMediaElementSource()</a></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> source = audioCtx.createMediaElementSource(myMediaElement);</div></pre></td></tr></table></figure>
<ul>
<li>直接来自于WebRTC，MediaStream。如摄像头、麦克风。具体API: <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/AudioContext/createMediaStreamSource" target="_blank" rel="external">AudioContext.createMediaStreamSource()</a>。这种方式可以看下MDN提供的<a href="https://mdn.github.io/voice-change-o-matic/" target="_blank" rel="external">Demo：the Voice-change-O-matic live</a>及<a href="https://github.com/mdn/voice-change-o-matic" target="_blank" rel="external">Demo源码</a></li>
</ul>
<h4 id="3-3-连接输入输出"><a href="#3-3-连接输入输出" class="headerlink" title="3.3 连接输入输出"></a>3.3 连接输入输出</h4><p>接下来需要创建改变音效的节点，并将这些节点连接起来，最终通过默认输出设备（通常是是设备扬声器）实质输出声音。<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/AudioContext/destination" target="_blank" rel="external">AudioContext.destination</a>就是最后需要连接的输出设备节点。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 以振荡器为例</span></div><div class="line"><span class="keyword">var</span> oscillator = audioCtx.createOscillator();</div><div class="line"><span class="keyword">var</span> gainNode = audioCtx.createGain();</div><div class="line"></div><div class="line">oscillator.connect(gainNode);</div><div class="line">gainNode.connect(audioCtx.destination);</div></pre></td></tr></table></figure>
<p>当然还有很多增益相关的节点，比如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> analyser = audioCtx.createAnalyser();  <span class="comment">//该节点可以从音频里提取时间、频率或者其它数据。</span></div><div class="line"><span class="keyword">var</span> distortion = audioCtx.createWaveShaper(); <span class="comment">//接口表示一个非线性的扭曲常被用来添加温暖的感觉。</span></div><div class="line"><span class="keyword">var</span> gainNode = audioCtx.createGain(); <span class="comment">//接口表示音量变更</span></div><div class="line"><span class="keyword">var</span> biquadFilter = audioCtx.createBiquadFilter(); <span class="comment">//表示一个简单的低阶滤波器</span></div><div class="line"><span class="keyword">var</span> convolver = audioCtx.createConvolver(); <span class="comment">//对给定的 AudioBuffer 执行线性卷积，通常用于实现混响效果。</span></div><div class="line"></div><div class="line">source = audioCtx.createMediaStreamSource(stream);</div><div class="line">source.connect(analyser);</div><div class="line">analyser.connect(distortion);</div><div class="line">distortion.connect(biquadFilter);</div><div class="line">biquadFilter.connect(convolver);</div><div class="line">convolver.connect(gainNode);</div><div class="line">gainNode.connect(audioCtx.destination);</div></pre></td></tr></table></figure>
<p>如果你一股脑添加了如上的节点，就会得到下面的音频节点图。这些节点都可以做对应的设置，来达到复杂的音频调节效果，这里就不做展开了，因为我也展不开……</p>
<p><img src="./images/web_audio_api/4.png" alt="音频图"></p>
<h4 id="3-4-设置音调、声音大小并播放"><a href="#3-4-设置音调、声音大小并播放" class="headerlink" title="3.4 设置音调、声音大小并播放"></a>3.4 设置音调、声音大小并播放</h4><p>终于到最后了，下面简单的做个设置就开始放吧：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">oscillator.type = <span class="string">'sine'</span>; <span class="comment">// sine 表示正弦波形 — 其他的波形值可以是 'square', 'sawtooth', 'triangle' and 'custom'</span></div><div class="line">oscillator.frequency.value = <span class="number">2500</span>; <span class="comment">// 单位是赫兹</span></div><div class="line">gainNode.gain.value = <span class="number">2</span>; <span class="comment">// 默认值是1</span></div><div class="line">oscillator.start(); <span class="comment">// 开始播放</span></div></pre></td></tr></table></figure>
<p>具体接口请参考<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Audio_API" target="_blank" rel="external">Web_Audio_API</a></p>
<h5 id="3-5-自产demo"><a href="#3-5-自产demo" class="headerlink" title="3.5 自产demo"></a>3.5 自产demo</h5><p>下面就上一个简单的demo，过程是利用XHR获取一个mp3文件，解码后播放，加了调节音量的按钮。</p>
<p><a href="https://github.com/fenglai0802/demo-list/tree/master/web_audio_api" target="_blank" rel="external">demo</a></p>
<p> PS:</p>
<ul>
<li><a href="https://github.com/ScottMichaud/AudioSampleLoader/blob/master/AudioSampleLoader.js" target="_blank" rel="external">AudioSampleLoader</a>这个库可以帮你简化XHR/buffer的操作。</li>
</ul>
<ul>
<li>Web Audio API的具体资料可以参考：<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Audio_API" target="_blank" rel="external">Web_Audio_API</a></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/01/Web-Audio-API-history/" itemprop="url">
                  Web Audio API history
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-03-01T19:33:19+08:00" content="2017-03-01">
              2017-03-01
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ol>
<li><p><code>&lt;bgsound&gt;</code>:</p>
<p> 早在1996年，IE3.0定义了<bgsound>标签，这应该是web最早的一个能播放音频的标签，但是它没有成为标准，始终只有IE支持。提供的功能比较有限，就是自动播放，支持.wav|.mid|.ua格式音频。<br> 当时最早的个人blog中用来播放背景音乐的代码就是用<code>&lt;bgsound&gt;</code>实现的。</bgsound></p>
</li>
<li><p><code>&lt;embed&gt;</code></p>
<p> OK，这个时候当时的浏览器厂商大哥NetScape坐不住了，没多久就退出了类似的功能标签<code>&lt;embed&gt;</code>。<br> 其相对于<code>&lt;bgsound&gt;</code>的特色：</p>
<ul>
<li>添加了一点交互，可以暂停/播放(可选)。</li>
<li><p>不仅仅支持音频格式文件，还支持当时比较高端的VRML Live3D的图形动画。</p>
<p>大哥发话，很快小弟safari，opare，firefox就纷纷跟进支持<code>&lt;embed&gt;</code>。</p>
</li>
</ul>
</li>
<li><p><code>&lt;object&gt;</code></p>
<p> 1994年W3C成立。1997年，随着HTML4的到来，W3C引入了 <code>&lt;object&gt;</code>标签，包括了图片、音频、视频等格式文件。可以说是第一款跨浏览器的音频播放标签。但是这个标签也有自己的弊端，例如标签臃肿，依赖插件，SEO困难等。</p>
</li>
<li><p><code>&lt;audio&gt;</code></p>
<p> 2008年，第一份正式的HTML5草案发布，引入了新的富媒体元素<code>&lt;video&gt;</code>， <code>&lt;audio&gt;</code>，<code>&lt;canvas&gt;</code>，这些标签的引入最大目的还是为了减少web富媒体应用对插件的依赖。从标签名就能区分功能，这点也非常有利于搜索引擎去索引资源。相比<code>&lt;object&gt;</code>，其有一下特点：</p>
<ul>
<li>标签语义化，结构简单；</li>
<li>脱离插件；</li>
<li><p>简单的js内置方法以及事件交互。</p>
<p>同样，也有缺陷：</p>
</li>
<li><p>缺少对音频数据的访问权限，在需要更动感的交互和更复杂的音效需求面前就显得力不从心。</p>
</li>
</ul>
</li>
<li><p><code>[Audio Data API]</code></p>
<p> 为了满足更复杂的需求，Mozilla社区又开始搞事，提出了<a href="https://wiki.mozilla.org/Audio_Data_API" target="_blank" rel="external">Audio Data API</a>，对<code>&lt;audio&gt;</code>标签进行了js能力方面的扩展，这套API主要是以提供读取写入音频数据接口为主。不过到现在基本已经废弃了，因为很多音频的专业效果处理需要涉及大量波形相关处理算法，对于普通开发者来说，成本太高，这也是为什么最后W3C推荐WEB AUDIO API了。</p>
</li>
<li><p><code>[Web Audio API]</code></p>
<p> 这套API最早是由Chrome社区提供并支持的，这是一套全新的相对独立的接口系统。对音频文件拥有更高的处理权限以及<strong>内置相关的音频专业效果处理</strong>（这一点很关键），可以完全独立于<code>&lt;audio&gt;</code>标签而存在。<br> Web Audio API的特点：</p>
<ol>
<li>更精确的时间控制；</li>
<li>可以完全独立<code>&lt;audio&gt;</code>，允许更多音频文件同事播放，用于游戏或者复杂音频应用场景；</li>
<li>模块化路由链接方式，让音频操作更加灵活形象；</li>
<li>实时的频域，时域数据访问/操作；</li>
<li><p>更多专业的音频处理方法</p>
<ol>
<li>音道分离/合并；</li>
<li>音频延时效果；</li>
<li>内置频率滤波器；</li>
<li>音频空间感效果以及多普勒效应模拟；</li>
<li>音频卷积运算（用于声场环境模拟）；</li>
<li>自定义波形生成器；</li>
<li>波形非线性失真处理。</li>
</ol>
</li>
</ol>
</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/02/28/扫描二维码跳转到ios或android的下载地址/" itemprop="url">
                  ios和android使用同一个二维码实现跳转下载链接
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-02-28T16:45:29+08:00" content="2017-02-28">
              2017-02-28
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="需求：扫描一个二维码，根据手机系统跳转到对应的下载页。ios扫描跳转到appstore，android扫描跳转到对应的浏览器或者市场下载。"><a href="#需求：扫描一个二维码，根据手机系统跳转到对应的下载页。ios扫描跳转到appstore，android扫描跳转到对应的浏览器或者市场下载。" class="headerlink" title="需求：扫描一个二维码，根据手机系统跳转到对应的下载页。ios扫描跳转到appstore，android扫描跳转到对应的浏览器或者市场下载。"></a>需求：扫描一个二维码，根据手机系统跳转到对应的下载页。ios扫描跳转到appstore，android扫描跳转到对应的浏览器或者市场下载。</h4><p>注意点：</p>
<ul>
<li>如果在微信中扫描二维码，需要手动跳转到手机的浏览器才能跳到下载页面。因为微信浏览器是不支持直接打开App Store页面的，以前可以通过微信中“查看原文“的function来跳转，微信升了几个版本又不行了，所以写了一个alert引导用户打开浏览器，蠢是蠢了点，但是靠谱。</li>
<li>如果要copy使用，改一下的url就好。</li>
</ul>
<p>下面直接上代码：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div></pre></td><td class="code"><pre><div class="line">	</div><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"txt"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">var</span> iosUrl = <span class="string">'https://itunes.apple.com/fr/app/wang-yi-dong-jianar-dong-cha/id1142482530?mt=8'</span>;  <span class="comment">//AppStore下载地址</span></div><div class="line">    <span class="keyword">var</span> anUrl = <span class="string">'http://www.lofter.com/rsc/android/loftcam.apk'</span>;  <span class="comment">//android下载地址</span></div><div class="line">    <span class="keyword">var</span> defaultUrl = <span class="string">'http://dongjian.163.com/'</span>;  <span class="comment">// pc端主页</span></div><div class="line"></div><div class="line">    jump(iosUrl, anUrl, defaultUrl);</div><div class="line"></div><div class="line">    <span class="comment">// 去下载</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">jump</span>(<span class="params">iosUrl, anUrl, defaultUrl</span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> ua = navigator.userAgent, appVer = navigator.appVersion;</div><div class="line">        <span class="keyword">var</span> isAndroid = ua.indexOf(<span class="string">'Android'</span>) &gt; <span class="number">-1</span> || ua.indexOf(<span class="string">'Linux'</span>) &gt; <span class="number">-1</span>;</div><div class="line">        <span class="keyword">var</span> isIOS = !!ua.match(<span class="regexp">/\(i[^;]+;( U;)? CPU.+Mac OS X/</span>);</div><div class="line">        <span class="comment">// 是安卓浏览器</span></div><div class="line">        <span class="keyword">if</span> (isAndroid) &#123;</div><div class="line">            <span class="built_in">window</span>.location.href = anUrl; <span class="comment">// 跳android端下载地址</span></div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 是iOS浏览器</span></div><div class="line">        <span class="keyword">if</span> (isIOS) &#123;</div><div class="line">            <span class="built_in">window</span>.location.href = iosUrl; <span class="comment">// 跳AppStore下载地址</span></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 是微信内部webView</span></div><div class="line">        <span class="keyword">if</span> (isWeixn()) &#123;</div><div class="line">            <span class="comment">// window.location.href = iosUrl; // 跳AppStore下载地址</span></div><div class="line">            <span class="keyword">var</span> txtNode = <span class="built_in">document</span>.createTextNode(<span class="string">'请点击右上角按钮, 点击使用浏览器打开'</span>);</div><div class="line">            <span class="built_in">document</span>.querySelector(<span class="string">'#txt'</span>).appendChild(txtNode);</div><div class="line">            alert(<span class="string">"请点击右上角按钮, 点击使用浏览器打开"</span>);</div><div class="line"></div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 是PC端</span></div><div class="line">        <span class="keyword">if</span> (isPC()) &#123;</div><div class="line">            <span class="built_in">window</span>.location.href = defaultUrl;  <span class="comment">// 公司主页</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 是微信浏览器</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">isWeixn</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">var</span> ua = navigator.userAgent.toLowerCase();</div><div class="line">        <span class="keyword">if</span>(ua.match(<span class="regexp">/MicroMessenger/i</span>)==<span class="string">"micromessenger"</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">isPC</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> uaInfo = navigator.userAgent;</div><div class="line">        <span class="keyword">var</span> agents = [<span class="string">"Android"</span>, <span class="string">"iPhone"</span>,</div><div class="line">            <span class="string">"SymbianOS"</span>, <span class="string">"Windows Phone"</span>,</div><div class="line">            <span class="string">"iPad"</span>, <span class="string">"iPod"</span>];</div><div class="line">        <span class="keyword">var</span> flag = <span class="literal">true</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> v = <span class="number">0</span>; v &lt; agents.length; v++) &#123;</div><div class="line">            <span class="keyword">if</span> (uaInfo.indexOf(agents[v]) &gt; <span class="number">0</span>) &#123;</div><div class="line">                flag = <span class="literal">false</span>;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> flag;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/02/27/函数式编程/" itemprop="url">
                  函数式编程
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-02-27T20:58:02+08:00" content="2017-02-27">
              2017-02-27
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/JS/" itemprop="url" rel="index">
                    <span itemprop="name">JS</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h3><p><strong>函数式编程</strong>（通常简称为FP）是指通过符合<strong>纯函数</strong>来构建软件的过程。它避免了<strong>共享状态（share state）</strong>，<strong>易变的数据（mutable data）</strong>以及<strong>副作用（side-effects）</strong>。函数式编程是一种编程范式，一种软件构建的思维方式。</p>
<p>以下这些名词定义中蕴含了许多思想，只有理解了它们，才能够开始掌握函数式编程真正的意义：</p>
<ul>
<li>纯函数（Pure functions）</li>
<li>函数复合（Function composition）</li>
<li>避免共享状态（Avoid shared state）</li>
<li>避免改变状态（Avoid mutating state）</li>
<li>避免副作用（Avoid side effects）</li>
</ul>
<h4 id="1-纯函数"><a href="#1-纯函数" class="headerlink" title="1.纯函数"></a>1.纯函数</h4><ul>
<li>给它同样的输入，总是返回同样的结果；</li>
<li>没有副作用；</li>
</ul>
<p>纯函数有着许多对函数式编程而言非常重要的属性，包括引用透明（你可以将一个函数调用替换成它的结果值，而不会对程序的运行造成影响。详细：<a href="http://zcfy.cc/article/master-the-javascript-interview-what-is-a-pure-function-2186.html" target="_blank" rel="external">什么是纯函数</a></p>
<h4 id="2-函数复合"><a href="#2-函数复合" class="headerlink" title="2.函数复合"></a>2.函数复合</h4><ul>
<li>函数复合是结合两个或多个函数，从而产生一个新函数或进行某些计算的过程。eg:<code>f(g(x))</code></li>
</ul>
<p>详细：<a href="http://zcfy.cc/article/master-the-javascript-interview-what-is-function-composition-2160.html" target="_blank" rel="external">函数复合</a></p>
<h4 id="3-共享状态"><a href="#3-共享状态" class="headerlink" title="3.共享状态"></a>3.共享状态</h4><ul>
<li><strong>共享状态</strong> 的意思是任意变量、对象或者内存空间存在于共享作用域下，或者作为对象的属性在各个作用域之间被传递。共享作用域包括全局作用域和闭包作用域。</li>
</ul>
<p>同步竞争和调用时序变更导致的问题都是共享状态常见的bug。</p>
<ul>
<li>同步竞争：举个例子，操作A向服务器请求改变B的状态，然后马上用C操作向服务器发送请求，该请求也会改变B的状态，不幸的是C操作有可能早于A返回，这就导致了同步竞争的bug。</li>
<li>调用时序变更：这个好理解，因为共享状态操作是有时序的，如果颠倒执行顺序就会导致共享状态出现错乱。</li>
</ul>
<h4 id="4-不可变性"><a href="#4-不可变性" class="headerlink" title="4.不可变性"></a>4.不可变性</h4><p>一个<strong>不可变的（immutable）对象</strong>是指一个对象不会在它创建之后被改变。不可变性是函数式编程的一个核心概念，因为没有它，你的程序中的数据流是有损的。</p>
<p>JavaScript 提供了一个方法，能够<strong>浅冻结</strong>一个对象：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">const</span> a = <span class="built_in">Object</span>.freeze(&#123;</div><div class="line">  foo: <span class="string">'Hello'</span>,</div><div class="line">  bar: <span class="string">'world'</span>,</div><div class="line">  baz: <span class="string">'!'</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line">a.foo = <span class="string">'Goodbye'</span>;</div><div class="line"><span class="comment">// Error: Cannot assign to read only property 'foo' of object Object</span></div></pre></td></tr></table></figure>
<p>但是深层仍旧可以被改变。</p>
<p>在许多函数式编程语言中，有特殊的不可变数据结构，被称为 <strong>trie 数据结构</strong>(trie 的发音为 tree)，这一结构有效地深冻结 —— 意味任何属性无论它的对象层级如何都不能被改变。</p>
<p>有一些 JavaScript 的库使用了 tries，包括 <a href="https://github.com/facebook/immutable-js" target="_blank" rel="external">Immutable.js</a> 和 <a href="https://github.com/swannodette/mori" target="_blank" rel="external">Mori</a>。</p>
<p>immutable更多使用实例：<a href="https://medium.com/javascript-scene/10-tips-for-better-redux-architecture-69250425af44" target="_blank" rel="external">10 Tips for Better Redux Architecture</a>。</p>
<p>ps: 在 JavaScript 中，很重要的一点是不要混淆了 <code>const</code> 和不变性。<code>const</code> 创建一个变量绑定，让该变量不能再次被赋值。<code>const</code> 并不创建不可变对象。你虽然不能改变绑定到这个变量名上的对象，但你仍然可以改变它的属性，这意味着 <code>const</code> 的变量仍然是可变的，而不是不可变的。</p>
<h4 id="5-副作用"><a href="#5-副作用" class="headerlink" title="5.副作用"></a>5.副作用</h4><p>副作用是指除了函数返回值以外，任何在函数调用之外观察到的应用程序状态改变。副作用包括：</p>
<ul>
<li>改变了任何外部变量或对象属性（例如，全局变量，或者一个在父级函数作用域链上的变量）</li>
<li>写日志</li>
<li>在屏幕输出</li>
<li>写文件</li>
<li>发网络请求</li>
<li>触发任何外部进程</li>
<li>调用另一个有副作用的函数</li>
</ul>
<h4 id="6-使用高阶函数提升重用性"><a href="#6-使用高阶函数提升重用性" class="headerlink" title="6.使用高阶函数提升重用性"></a>6.使用高阶函数提升重用性</h4><p><strong>高阶函数</strong>指的是一个函数以函数为参数，或以函数为返回值，或者既以函数为参数又以函数为返回值。高阶函数经常用于：</p>
<ul>
<li>抽象或隔离行为、作用，异步控制流程作为回调函数，promises，<a href="https://en.wikipedia.org/wiki/Monad_%28functional_programming%29" target="_blank" rel="external">monads</a>，等等……</li>
<li>创建可以泛用于各种数据类型的功能</li>
<li>部分应用于函数参数（偏函数应用）或创建一个柯里化的函数，用于复用或函数复合。</li>
<li>接受一个函数列表并返回一些由这个列表中的函数组成的复合函数。</li>
</ul>
<p>函数式编程倾向于复用一组通用的函数功能来处理数据。面向对象编程倾向于把方法和数据集中到对象上。那些被集中的方法只能用来操作设计好的数据类型，通常是那些包含在特定对象实例上的数据。</p>
<p>在函数式编程里，对任何类型的数据一视同仁。同样的 map() 操作可以 map 对象、字符串、数字或任何别的类型，因为它接受一个函数参数，来适当地操作给定类型。函数式编程通过使用高阶函数来实现这一技巧。</p>
<p>关于高阶函数就不展开了。自行google。</p>
<h4 id="7-命令式-vs-声明式"><a href="#7-命令式-vs-声明式" class="headerlink" title="7.命令式 vs 声明式"></a>7.命令式 vs 声明式</h4><p>函数式编程是<strong>声明式</strong>的，而不是<strong>命令式</strong>的，应用程序的状态通过纯函数流转。</p>
<ul>
<li>声明式：意思是说程序逻辑不需要通过明确描述控制流程来表达。程序抽象了控制流过程，花费大量代码描述的是数据流：即做什么。</li>
<li>命令式：程序花费大量代码来描述用来达成期望结果的特定步骤 —— 控制流：即如何做。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// 命令式</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> doubleMap = numbers =&gt; &#123;</div><div class="line">  <span class="keyword">const</span> doubled = [];</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; numbers.length; i++) &#123;</div><div class="line">    doubled.push(numbers[i] * <span class="number">2</span>);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> doubled;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(doubleMap([<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])); <span class="comment">// [4, 6, 8]</span></div><div class="line"></div><div class="line"><span class="comment">// 声明式</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> doubleMap = numbers =&gt; numbers.map(n =&gt; n * <span class="number">2</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(doubleMap([<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])); <span class="comment">// [4, 6, 8]</span></div><div class="line"></div><div class="line"><span class="comment">// 命令式 代码中频繁使用语句。语句是指一小段代码，它用来完成某个行为。</span></div><div class="line"><span class="comment">// 声明式 代码更多依赖表达式。表达式是指一小段代码，它用来计算某个值。</span></div></pre></td></tr></table></figure>
<h4 id="8-结论"><a href="#8-结论" class="headerlink" title="8.结论"></a>8.结论</h4><p>函数式编程偏好：</p>
<ul>
<li>使用纯函数而不是使用共享状态和副作用</li>
<li>让可变数据成为不可变的</li>
<li>用函数复合替代命令控制流</li>
<li>使用高阶函数来操作许多数据类型，创建通用、可复用功能取代只是操作集中的数据的方法。</li>
<li>使用声明式而不是命令式代码（关注做什么，而不是如何做）</li>
<li>使用表达式替代语句</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/02/26/HTTP/" itemprop="url">
                  HTTP/2 vs HTTP/1.X
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-02-26T12:02:16+08:00" content="2017-02-26">
              2017-02-26
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>HTTP/2 vs HTTP/1.X</p>
<h4 id="1-什么是HTTP-2"><a href="#1-什么是HTTP-2" class="headerlink" title="1. 什么是HTTP/2"></a>1. 什么是HTTP/2</h4><p>超文本传输协议第二版，是自HTTP协议1999年HTTP1.1发布后的首个更新，主要是基于SPDY/2协议（是google开发的基于TCP的应用层协议，它的设计目标是降低 50% 的页面加载时间。用以最小化网络延迟，提升网络速度，优化用户的网络体验）。</p>
<p>HTTP/2跟SPDY区别：</p>
<ul>
<li>HTTP/2支持明文HTTP传输，而SPDY强制使用HTTPS</li>
<li>HTTP/2消息头的压缩算法采用HPACK，而非SPDY采用的DELEFT</li>
</ul>
<h4 id="2-与HTTP-1-X相比，区别有："><a href="#2-与HTTP-1-X相比，区别有：" class="headerlink" title="2. 与HTTP/1.X相比，区别有："></a>2. 与HTTP/1.X相比，区别有：</h4><ol>
<li><p>HTTP/2采用的是二进制格式传输数据，而非HTTP/1.X文本格式。二进制格式在协议的解析和优化扩展上带来更多的优势和可能。比起文本格式，二进制协议解析更高效，错误更少。</p>
</li>
<li><p>HTTP/2是完全多路复用，而非HTTP/1.X有序并阻塞的。<strong>只需要一个连接即可实现并行</strong>，这个很关键，高效。直白的说就是所有请求都是通过一个TCP连接并发完成。HTTP/1.X虽然能利用一个连接完成多次请求，但是多个请求之间有先后顺序的，后面发送的请求必须等待前面的请求返回了才能发送响应。就会导致请求被阻塞，而HTTP/2做到了真正的并发请求。同时，流还支持优先级和流量控制。</p>
<p> HTTP/1.X 有个问题叫线端阻塞(head-of-line blocking), 它是指一个连接(connection)一次只提交一个请求的效率比较高, 多了就会变慢。 HTTP/1.1 试过用流水线(pipelining)来解决这个问题, 但是效果并不理想(数据量较大或者速度较慢的响应, 会阻碍排在他后面的请求). 此外, 由于网络媒介(intermediary )和服务器不能很好的支持流水线, 导致部署起来困难重重。而多路传输(Multiplexing)能很好的解决这些问题, 因为它能同时处理多个消息的请求和响应; 甚至可以在传输过程中将一个消息跟另外一个掺杂在一起。所以客户端只需要一个连接就能加载一个页面。<br> <img src="./images/HTTP/Multiplexing.png" alt="Multiplexing" title="Multiplexing"></p>
</li>
<li><p>HTTP/2 对消息头采用 HPACK 进行压缩传输，能够节省消息头占用的网络的流量，增大有效数据传输量。</p>
</li>
<li><p>Server Push：让服务器可以响应主动“推送”到客户端缓存中。例如服务端可以主动把 JS 和 CSS 文件推送给客户端，而不需要客户端解析 HTML 再发送这些请求。当客户端需要的时候，它已经在客户端了。</p>
</li>
</ol>
<h4 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h4><p>本文简化了很多 HTTP/2 协议中的具体细节，只描述了 HTTP/2 中主要特性实现的基本过程。</p>
<p>如果你想实现一个支持 HTTP/2 的服务器，那么你可以移步 <a href="https://http2.github.io/" target="_blank" rel="external">HTTP/2</a> 官网 做更多了解，它还提供了一份已经实现 HTTP/2 的项目列表： <a href="https://github.com/http2/http2-spec/wiki/Implementations" target="_blank" rel="external">https://github.com/http2/http2-spec/wiki/Implementations</a> 。</p>
<p>另外，关于 HTTP/2 性能如何，可以参考官方小组给出的例子： <a href="https://http2.akamai.com/demo" target="_blank" rel="external">https://http2.akamai.com/demo</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/20/Atom中文件识别默认语法修改/" itemprop="url">
                  grammar更改笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-11-20T13:18:57+08:00" content="2016-11-20">
              2016-11-20
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Atom中文件识别默认语法修改"><a href="#Atom中文件识别默认语法修改" class="headerlink" title="Atom中文件识别默认语法修改"></a>Atom中文件识别默认语法修改</h1><ul>
<li><em>需求</em>：公司使用自己开发的css预处理器mcss来进行web样式开发，这类文件的后缀为.mcss，在Atom中无法识别，因此每次打开这类文件，都需要ctrl+shift+L选择语言(grammar)版本，通常会选择scss或者less来代替一下。重复度比较大。</li>
<li><em>思路</em>：解决这个问题有2个办法：一个就是写个Atom插件，让Atom可以识别mcss语言；另一个就是将就策略，让Atom自动用scss或者less的语法来识别.mcss文件。考虑到办法一短时间无法实现（好吧，其实是因为菜），这里先用方法二处理下，后续有缘再进行插件的开发。</li>
</ul>
<h2 id="Atom语法介绍"><a href="#Atom语法介绍" class="headerlink" title="Atom语法介绍"></a>Atom语法介绍</h2><p>加载了一个文件以后，Atom会做一些事情来试图识别出文件的类型。大部分情况下，Atom 会通过文件的扩展名（.md 通常是一个 Markdown 文件，等等）来完成这项工作，但有时只通过扩展名难以判断，它会对文件内容进行一些检查来确定。</p>
<p>如果加载了一个 Atom 无法判断语法的文件，它会默认为是最简单的纯文本类型（Plain Text）。如果它把文件默认为纯文本，或者弄错了文件类型，再或者由于一些原因你想修改文件的当前作用语法，可以按下 ctrl-shift-L 调出语法选择器。</p>
<p><img src="./images/Atom中文件识别默认语法修改/grammar.png" alt=""></p>
<p>一旦手动修改了一个文件的语法，Atom会记住它，除非你将语法设置回自动检测，或者手动选择一个不同的语法。</p>
<p>语法选择器的功能在 <a href="https://github.com/atom/grammar-selector" target="_blank" rel="external">atom/grammar-selector</a> 这个 package 里实现。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>在Atom的配置文件夹目录下有一个init.coffee的文件，用于做Atom初始化设置。</p>
<p>在其中添加代码</p>
<pre><code># add &quot;.mcss&quot; to SCSS grammar:
for grammar of atom.grammars.grammars
  if grammar.name is &quot;Less&quot;
    grammar.fileTypes.push(&apos;mcss&apos;)
atom.grammars.onDidAddGrammar (grammar) -&gt;
  if grammar.name is &quot;Less&quot;
    grammar.fileTypes.push(&apos;mcss&apos;)
</code></pre><p>表示在Less的语法中，添加识别文件类型mcss。从而使mcss文件能够被当做Less识别</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/06/文件上传组件小结/" itemprop="url">
                  文件上传组件小结
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-11-06T15:05:50+08:00" content="2016-11-06">
              2016-11-06
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/JS/" itemprop="url" rel="index">
                    <span itemprop="name">JS</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="文件-图片上传组件小结"><a href="#文件-图片上传组件小结" class="headerlink" title="文件/图片上传组件小结"></a>文件/图片上传组件小结</h1><p>分为两部分来总结，第一部分为<em>自定义样式</em>，第二部分为<em>js实现</em>。</p>
<h2 id="一-自定义样式"><a href="#一-自定义样式" class="headerlink" title="一. 自定义样式"></a>一. 自定义样式</h2><p>通常来说，<code>input[type=file]</code>的默认样式都不能满足视觉的需求，所以需要套壳包装。常用的方式就是隐藏默认上传控件，并在其父级添加一个元素（比如label标签）来自定义样式，这样可以做到保留功能同时自定义样式。具体css代码如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//HTML5</div><div class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">''</span> <span class="attr">ref</span>=<span class="string">preview</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">"u-btn btn-upload"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">ref</span>=<span class="string">files</span>  <span class="attr">on-change</span>=<span class="string">&#123;this.fileChange()&#125;</span>&gt;</span>上传图片</div><div class="line"><span class="tag">&lt;/<span class="name">label</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">//CSS</div><div class="line">.u-btn &#123;   //基础按钮样式</div><div class="line">    font: inherit;</div><div class="line">    position:relative;</div><div class="line">    line-height: 34px;</div><div class="line">    display: inline-block;</div><div class="line">    box-sizing: border-box;</div><div class="line">    height: 34px;</div><div class="line">    margin: 0;</div><div class="line">    padding: 0 12px;</div><div class="line">    cursor: pointer;</div><div class="line">    text-decoration: none;</div><div class="line">    color: #444;</div><div class="line">    border: 1px solid #ddd;</div><div class="line">    -moz-border-radius: 3px;</div><div class="line">    border-radius: 3px;</div><div class="line">    background: #f4f4f4;</div><div class="line">    -webkit-appearance: none;</div><div class="line">&#125;</div><div class="line">.u-btn:focus, .u-btn:hover &#123;</div><div class="line">    text-decoration: none;border: 1px solid #adadad;background: #e5e5e5;</div><div class="line">&#125;</div><div class="line">.btn-upload &#123;  </div><div class="line">    overflow: hidden;</div><div class="line">    input &#123;</div><div class="line">        opacity: 0;</div><div class="line">        filter:alpha(opacity=0);</div><div class="line">        font-size: 100px;</div><div class="line">        position: absolute;</div><div class="line">        top: 0;right: 0</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="二-js实现"><a href="#二-js实现" class="headerlink" title="二. js实现"></a>二. js实现</h2><p>需求：上传单张图片，并能预览。</p>
<p>框架：<a href="https://github.com/regularjs/regular" target="_blank" rel="external">regular</a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 这里使用regular框架，不详细说明</span></div><div class="line"><span class="comment">// 在`input[type=file]`上绑定了`onchange`监听事件,回调为`fileChange`方法</span></div><div class="line">fileChange: <span class="function"><span class="keyword">function</span>(<span class="params">ev</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> input = <span class="keyword">this</span>.$refs.files;  <span class="comment">// regular获取节点的方式</span></div><div class="line">    <span class="keyword">var</span> preview = <span class="keyword">this</span>.$refs.preview;  <span class="comment">// 获取预览dom</span></div><div class="line">    <span class="keyword">var</span> file = input.files[<span class="number">0</span>]; <span class="comment">// 获取上传的文件</span></div><div class="line">    <span class="keyword">if</span> (!<span class="regexp">/\/(?:jpeg|jpg|png)/i</span>.test(file.type)) &#123; <span class="comment">//检查上传文件的类型，此处需要图片类型的文件，并且规定了后缀条件。</span></div><div class="line">        <span class="comment">//提示错误信息</span></div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">var</span> reader = <span class="keyword">new</span> FileReader();</div><div class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</div><div class="line">    reader.onload = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">var</span> result = self.img = <span class="keyword">this</span>.result; <span class="comment">// this指向reader,这个result即上传文件数据，将这个result用ajax传输即可。</span></div><div class="line"></div><div class="line">        <span class="comment">// 组件操作，可忽略</span></div><div class="line">        self.data.show = <span class="literal">true</span>;</div><div class="line">        self.data.str = <span class="string">'重新选择'</span></div><div class="line">        self.$emit(<span class="string">'upload'</span>);</div><div class="line"></div><div class="line">        preview.src = result; <span class="comment">// 预览dom设置src</span></div><div class="line"></div><div class="line">        <span class="comment">// console.log(preview.naturalWidth)</span></div><div class="line">        <span class="comment">// console.log(preview.naturalHeight)</span></div><div class="line">        <span class="comment">// 组件操作，可忽略</span></div><div class="line">        self.imgNatrualSize = &#123;</div><div class="line">            width: preview.naturalWidth,</div><div class="line">            height: preview.naturalHeight</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 获取文件名</span></div><div class="line">        <span class="keyword">var</span> imgName = input.value;</div><div class="line">        <span class="keyword">var</span> index = imgName.lastIndexOf(<span class="string">'\\'</span>);</div><div class="line">        self.imgName = index !== <span class="number">-1</span> ? imgName.slice(index+<span class="number">1</span>) : imgName;</div><div class="line"></div><div class="line">        input.value = <span class="string">''</span>; <span class="comment">// 清空图片上传框的值</span></div><div class="line"></div><div class="line">   &#125;;</div><div class="line"></div><div class="line">   reader.readAsDataURL(file); <span class="comment">// 将文件转成base64的格式.</span></div><div class="line">&#125;,</div></pre></td></tr></table></figure>
<h2 id="附录-FileReader-API简介"><a href="#附录-FileReader-API简介" class="headerlink" title="附录 FileReader API简介"></a>附录 FileReader API简介</h2><p>###1. FileReader对象的方法</p>
<p>FileReader 的实例拥有 4 个方法，其中 3 个用以读取文件，另一个用来中断读取。下面的表格列出了这些方法以及他们的参数和功能，需要注意的是 ，无论读取成功或失败，方法并不会返回读取结果，这一结果存储在 result属性中。</p>
<table>
<thead>
<tr>
<th style="text-align:left">方法名</th>
<th style="text-align:left">参数</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">abort</td>
<td style="text-align:left">none</td>
<td style="text-align:left">中断读取</td>
</tr>
<tr>
<td style="text-align:left">readAsBinaryString</td>
<td style="text-align:left">file</td>
<td style="text-align:left">将文件读取为二进制码</td>
</tr>
<tr>
<td style="text-align:left">readAsDataURL</td>
<td style="text-align:left">file</td>
<td style="text-align:left">将文件读取为 DataURL</td>
</tr>
<tr>
<td style="text-align:left">readAsText</td>
<td style="text-align:left">file</td>
<td style="text-align:left">将文件读取为文本</td>
</tr>
</tbody>
</table>
<p><em>readAsText</em>：该方法有两个参数，其中第二个参数是文本的编码方式，默认值为 UTF-8。这个方法非常容易理解，将文件以文本方式读取，读取的结果即是这个文本文件中的内容。</p>
<p><em>readAsBinaryString</em>：该方法将文件读取为二进制字符串，通常我们将它传送到后端，后端可以通过这段字符串存储文件。</p>
<p><em>readAsDataURL</em>：这是例子程序中用到的方法，该方法将文件读取为一段以 data: 开头的字符串，这段字符串的实质就是 Data URL，Data URL是一种将小文件直接嵌入文档的方案。这里的小文件通常是指图像与 html 等格式的文件。</p>
<h3 id="2-FileReader对象的事件"><a href="#2-FileReader对象的事件" class="headerlink" title="2. FileReader对象的事件"></a>2. FileReader对象的事件</h3><p>FileReader 包含了一套完整的事件模型，用于捕获读取文件时的状态，下面这个表格归纳了这些事件。</p>
<table>
<thead>
<tr>
<th style="text-align:left">事件</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">onabort</td>
<td style="text-align:left">中断时触发</td>
</tr>
<tr>
<td style="text-align:left">onerror</td>
<td style="text-align:left">出错时触发</td>
</tr>
<tr>
<td style="text-align:left">onload</td>
<td style="text-align:left">文件读取成功完成时触发</td>
</tr>
<tr>
<td style="text-align:left">onloadend</td>
<td style="text-align:left">读取完成触发，无论成功或失败</td>
</tr>
<tr>
<td style="text-align:left">onloadstart</td>
<td style="text-align:left">读取开始时触发</td>
</tr>
<tr>
<td style="text-align:left">onprogress</td>
<td style="text-align:left">读取中</td>
</tr>
</tbody>
</table>
<p>文件一旦开始读取，无论成功或失败，实例的 result 属性都会被填充。如果读取失败，则 result 的值为 null ，否则即是读取的结果，绝大多数的程序都会在成功读取文件的时候，抓取这个值。</p>
<pre><code>var reader = new FileReader();
reader.onload = function() {  
    this.result;  
};
</code></pre><p><em>ps</em> 可以利用这些事件制作文件读取的进度条，此处不详细展开，有空在做补充。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/17/git子模块/" itemprop="url">
                  git子模块
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-17T15:31:17+08:00" content="2016-09-17">
              2016-09-17
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/git/" itemprop="url" rel="index">
                    <span itemprop="name">git</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="git子模块"><a href="#git子模块" class="headerlink" title="git子模块"></a>git子模块</h1><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>在开发项目A时，需要依赖项目B（实时更新）。同时希望A,B能够独立处理。</p>
<h3 id="实际案例"><a href="#实际案例" class="headerlink" title="实际案例"></a>实际案例</h3><p>举例来说，现在我参与的项目<strong>网易有数（Youdata）</strong>，它依赖了一个独立开发的图形库<strong>NEV</strong>，他们是并行开发的。如果只是简单的将<strong>NEV</strong>的代码copy到Youdata中，显然是有点傻逼，因为无法自动更新NEV的迭代。</p>
<h3 id="处理方式"><a href="#处理方式" class="headerlink" title="处理方式"></a>处理方式</h3><p>Git 通过子模块处理这个问题。子模块允许你将一个 Git仓库当作另外一个Git仓库的子目录。这允许你克隆另外一个仓库到你的项目中并且保持你的提交相对独立。</p>
<h3 id="子模块相关操作："><a href="#子模块相关操作：" class="headerlink" title="子模块相关操作："></a>子模块相关操作：</h3><h4 id="1-添加子模块-git-submodule-add-url-path"><a href="#1-添加子模块-git-submodule-add-url-path" class="headerlink" title="1.添加子模块 $ git submodule add [url] [path]"></a>1.添加子模块 <code>$ git submodule add [url] [path]</code></h4><p>如</p>
<pre><code>$ git sub module add https://git.hz.netease.com/git/NEV/NEV.git src/webapp/res/nev
</code></pre><p>操作成功之后会生成一个.submodules的文件，其中记录了每个submodule的引用信息，知道在当前项目的位置以及仓库的所在。</p>
<h4 id="2-查看子模块-git-submodule"><a href="#2-查看子模块-git-submodule" class="headerlink" title="2.查看子模块 $ git submodule"></a>2.查看子模块 <code>$ git submodule</code></h4><p>如图</p>
<p><img src="./images/git子模块/1.png" alt=""></p>
<p>ps: 如果子模块前面有一个-，说明子模块文件还未检入（空文件夹）</p>
<h4 id="3-初始化子模块：-git-submodule-init-—-在首次检出仓库时运行一次"><a href="#3-初始化子模块：-git-submodule-init-—-在首次检出仓库时运行一次" class="headerlink" title="3.初始化子模块： $ git submodule init — 在首次检出仓库时运行一次"></a>3.初始化子模块： <code>$ git submodule init</code> — 在首次检出仓库时运行一次</h4><h4 id="4-更新子模块：-git-submodule-update"><a href="#4-更新子模块：-git-submodule-update" class="headerlink" title="4. 更新子模块：$ git submodule update"></a>4. 更新子模块：<code>$ git submodule update</code></h4><p>这个命令才是最常用的，每次子模块更新或者切换分支了，就执行一次。</p>
<h4 id="5-删除子模块："><a href="#5-删除子模块：" class="headerlink" title="5. 删除子模块："></a>5. 删除子模块：</h4><ul>
<li><code>$ git rm -cached [path]</code></li>
<li>编辑<code>.gitmodules</code>文件，删除对应的子模块配置</li>
<li>编辑<code>.git/config</code>文件，删除对应的子模块配置</li>
<li>最后删除子模块的目录</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/14/图解密码技术总结/" itemprop="url">
                  图解密码技术总结
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-14T15:42:58+08:00" content="2016-09-14">
              2016-09-14
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/书/" itemprop="url" rel="index">
                    <span itemprop="name">书</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="《图解密码技术》总结"><a href="#《图解密码技术》总结" class="headerlink" title="《图解密码技术》总结"></a>《图解密码技术》总结</h1><h3 id="一-历史上的密码"><a href="#一-历史上的密码" class="headerlink" title="一. 历史上的密码"></a>一. 历史上的密码</h3><h5 id="1-1-凯撒密码："><a href="#1-1-凯撒密码：" class="headerlink" title="1.1. 凯撒密码："></a>1.1. <strong>凯撒密码</strong>：</h5><ul>
<li>将明文按照字母表进行一定的“平移”来进行加密的加密算法。</li>
</ul>
<p><img src="./images/图解密码技术总结/1.1.png" alt=""></p>
<h5 id="1-2-简单替换密码："><a href="#1-2-简单替换密码：" class="headerlink" title="1.2. 简单替换密码："></a>1.2. <strong>简单替换密码</strong>：</h5><ul>
<li>两套字母表进行乱序一一对应，那么无论哪种对应关系都可以作为密码来使用。这种将明文中用到的字母表替换成另一套字母表的密码就是简单替换密码（simple substitution cipher）。如下图。</li>
</ul>
<p><img src="./images/图解密码技术总结/1.2.png" alt=""></p>
<h5 id="1-3-Enigma："><a href="#1-3-Enigma：" class="headerlink" title="1.3. Enigma："></a>1.3. <strong>Enigma</strong>：</h5><ul>
<li>相信很多人看过由卷福饰演图灵的电影《模仿游戏》，那么对于二战时期大名鼎鼎的德国密码机Enigma一定不陌生了。</li>
<li>Enigma在德语中的意思就是“谜”。</li>
<li>发明之初是作为商用的，到了纳粹时期，经过改良后用于军事用途。</li>
<li>Enigma是一种由键盘、齿轮、电池和灯泡组成的机器。通过一台机器可以完成加密解密两种操作。</li>
<li>其实<strong>Enigma相当于一个密码算法</strong>， 它并不依赖于<strong>隐蔽式安全性</strong>（security by obscurity）—隐蔽式安全性：顾名思义就是依靠算法的隐蔽性来获得安全保障，一旦算法被曝光就会被破解。而Enigma密码机就算被密码破译者得到，只要不知道Enigma的设置（相当于密钥），就无法破译密码。</li>
</ul>
<h6 id="1-3-1-下图为Enigma进行加密通信的过程图。"><a href="#1-3-1-下图为Enigma进行加密通信的过程图。" class="headerlink" title="1.3.1 下图为Enigma进行加密通信的过程图。"></a>1.3.1 下图为Enigma进行加密通信的过程图。</h6><p><img src="./images/图解密码技术总结/1.3.png" alt=""></p>
<h6 id="1-3-2-Enigma加密"><a href="#1-3-2-Enigma加密" class="headerlink" title="1.3.2 Enigma加密"></a>1.3.2 Enigma加密</h6><p>下图为Enigma进行加密nacht的过程图。</p>
<p><img src="./images/图解密码技术总结/1.4.png" alt=""></p>
<p>在进行通信之前，发送者和接受者都需要持有国防军密码本，这里面记载了发送者和接受者需要使用的每日密码。如果有一本国防军密码本被缴获，那就需要全部替换新的密码本。这里就涉及到密钥的配送问题。</p>
<ol>
<li><p>设置Enigma</p>
<p> 发送者查阅国防军密码本，找到当天的<strong>每日密码</strong>，并按照该密码设置Enigma。</p>
</li>
<li><p>加密通信密码</p>
<p> 接下来，发送者需要想出3个字母（这里假设为psv），并将其加密。这3个字母称为<strong>通信密码</strong>。</p>
<p> 由于Enigma的时代，无线电的质量很差，可能发生通信错误。所以通信密码需要连续输入两次（psvpsv），以便接受者可以进行校验。在Enigma中输入psvpsv这6个字母，则会得到对应的密文并记录，假设密文为ATCDVT（密文用大写字母表示）。</p>
<p> 这里可以看出，每日密码其实是用来加密通信密钥的密钥。这样的密钥，一般称为<strong>密钥加密密钥</strong>（Key Encryptiong Key，KEK）。</p>
</li>
<li><p>重新设置Enigma</p>
<p> 此时，根据通信密码（psv）重新设置Enigma。</p>
</li>
<li><p>加密信息</p>
<p> 接下来，发送者就可以对消息进行加密了。假设消息（明文）为nacht，进过加密得到KXNWP。</p>
</li>
<li><p>拼接</p>
<p> 最后，将2中得到的通信密码“ATCDVT”与加密后的消息“KXNWP”进行拼接，将“ATCDVTKXNWP”作为电文通过无线电发送出去。</p>
</li>
</ol>
<h6 id="1-3-3-Enigma解密"><a href="#1-3-3-Enigma解密" class="headerlink" title="1.3.3 Enigma解密"></a>1.3.3 Enigma解密</h6><p>理解了加密步骤，解密就简单了。</p>
<ul>
<li>首先将密文分成两部分，即开头6个字母ATCDVT和剩下的字母KXNWP。</li>
<li>根据和发送者相同的每日密码设置Enigma。将ATCDVT破译得到psvpsv。</li>
<li>根据psv设置Enigma。</li>
<li>然后破译剩下的字母KXNWP，得到明文nacht。</li>
</ul>
<h6 id="1-3-4-Enigma的弱点"><a href="#1-3-4-Enigma的弱点" class="headerlink" title="1.3.4 Enigma的弱点"></a>1.3.4 Enigma的弱点</h6><ul>
<li>通信密码连续输入两次。</li>
<li>通信密码人为选定。理论上通信密码应该具有不可预测性。</li>
<li>必须派发国防军密码本。前面也说了，如果泄露一本，就需要全部替换新的。</li>
</ul>
<p>===</p>
<h3 id="二-对称密码"><a href="#二-对称密码" class="headerlink" title="二. 对称密码"></a>二. 对称密码</h3><ul>
<li>所谓对称密码，就是说加密和解密使用的是相同的密钥。</li>
<li>算法的核心是利用位运算中“异或”的方式来实现的。简单的讲：“01”组成的比特序列经过与密钥的一次“异或”<br>即可得到密文，再和相同的密钥进行一次“异或”就能还原明文。</li>
<li>对称密码的算法：DES、三重DES、AES（AES的标准所选定的密码算法叫作Rijndael）。</li>
</ul>
<h4 id="2-1-一次性密码本-—-绝对不会被破译的密码"><a href="#2-1-一次性密码本-—-绝对不会被破译的密码" class="headerlink" title="2.1 一次性密码本 — 绝对不会被破译的密码"></a>2.1 一次性密码本 — 绝对不会被破译的密码</h4><ul>
<li>原理是： 将明文和一串随机的比特序列进行XOR运算。</li>
<li>那么为什么它是无法破译的呢：无法破译并不是说不能解出明文，而是说无法判断它是否是正确的明文，因为在解密的过程（暴力破解）中所有的排列组合都会出现，因此就无法判断哪一个才是正确的明文。</li>
</ul>
<p>===</p>
<h3 id="三-公钥密码—用公钥加密，用私钥解密"><a href="#三-公钥密码—用公钥加密，用私钥解密" class="headerlink" title="三. 公钥密码—用公钥加密，用私钥解密"></a>三. 公钥密码—用公钥加密，用私钥解密</h3><ul>
<li>书里关于投币寄存柜的比喻很好：钱是关闭寄存柜的密钥，钥匙是打开寄存柜的密钥。类比公钥密码，钱就是公钥，谁都可以用来加密寄存柜，但是要打开寄存柜只能用私钥“钥匙”。</li>
</ul>
<h4 id="3-1-密钥配送问题"><a href="#3-1-密钥配送问题" class="headerlink" title="3.1 密钥配送问题"></a>3.1 密钥配送问题</h4><p>如果密钥如同密文一样通过网络直接发送，那么也很容易被窃听。那么如何解决这个问题呢。</p>
<ul>
<li>通过事先共享的密钥来解决。</li>
<li>通过密钥分配中心来解决。</li>
<li>通过Diffie-Hellman密钥交换来解决。</li>
<li>通过公钥密码来解决。</li>
</ul>
<h4 id="3-2-那么如何通过公钥密钥来解决密钥配送问题呢"><a href="#3-2-那么如何通过公钥密钥来解决密钥配送问题呢" class="headerlink" title="3.2 那么如何通过公钥密钥来解决密钥配送问题呢"></a>3.2 那么如何通过公钥密钥来解决密钥配送问题呢</h4><h5 id="3-2-1-首先来介绍下公钥的通信流程"><a href="#3-2-1-首先来介绍下公钥的通信流程" class="headerlink" title="3.2.1 首先来介绍下公钥的通信流程"></a>3.2.1 首先来介绍下公钥的通信流程</h5><ol>
<li>Bob生成一个包含公钥和私钥的密钥对。私钥有Bob自己保管。</li>
<li>Bob将公钥发送给Alice。Bob的公钥被窃听者Eve获取也没关系。将公钥发送给Alice表示让他用这个公钥加密消息并发送给Bob。</li>
<li>Alice用Bob的公钥加密消息，加密后的消息只能用Bob的私钥才能解密。Alice的公钥是无法解密的。</li>
<li>Alice将密文发送给Bob。这样密文就算被窃听也没有关系。</li>
<li>Bob用私钥进行解密。</li>
</ol>
<p><img src="./images/图解密码技术总结/3.1.png" alt=""></p>
<h5 id="3-2-2-解决密钥配送问题"><a href="#3-2-2-解决密钥配送问题" class="headerlink" title="3.2.2 解决密钥配送问题"></a>3.2.2 解决密钥配送问题</h5><p>因此，我们可以用公钥来加密对称密码的密钥，从而解决密钥配送的问题。</p>
<h5 id="3-2-3-公钥密码无法解决的问题"><a href="#3-2-3-公钥密码无法解决的问题" class="headerlink" title="3.2.3 公钥密码无法解决的问题"></a>3.2.3 公钥密码无法解决的问题</h5><ol>
<li>公钥密码的速度只有对称密码的几百分之一。速度问题如何解决。</li>
<li>如何判断公钥的正确合法性，这个问题是公钥认证的问题。举例：<strong>中间人攻击</strong>，如图</li>
</ol>
<p><img src="./images/图解密码技术总结/3.2.png" alt=""></p>
<h5 id="3-2-4-公钥密码的算法"><a href="#3-2-4-公钥密码的算法" class="headerlink" title="3.2.4 公钥密码的算法"></a>3.2.4 公钥密码的算法</h5><ul>
<li>算法的核心是利用mod运算（取余运算）</li>
<li>简单介绍下现在使用最广泛的公钥密码算法 — RSA<ul>
<li>密文 = 明文 E MOD N （RSA加密：明文的E次方除以N的余数）</li>
<li>明文 = 密文 D MOD N （RSA解密：密文的D次方除以N的余数）</li>
<li>E和N的组合就是公钥</li>
<li>D和N的组合就是私钥</li>
</ul>
</li>
</ul>
<p>===</p>
<h3 id="四-混合密码系统-—-用对称密码提高速度，用公钥密码保护会话密钥"><a href="#四-混合密码系统-—-用对称密码提高速度，用公钥密码保护会话密钥" class="headerlink" title="四. 混合密码系统 — 用对称密码提高速度，用公钥密码保护会话密钥"></a>四. 混合密码系统 — 用对称密码提高速度，用公钥密码保护会话密钥</h3><p>在3.2.3中提到公钥密码还有两个很大的问题。一是速度问题，二是认证问题。这一节介绍的混合密码系统可以解决第一个速度问题。第二个问题在后面的小节中介绍。</p>
<h4 id="4-1-混合密码系统组成"><a href="#4-1-混合密码系统组成" class="headerlink" title="4.1 混合密码系统组成"></a>4.1 混合密码系统组成</h4><ul>
<li>用对称密码加密消息</li>
<li>通过伪随机数生成器生成对称密码加密中使用的会话秘钥</li>
<li>用公钥密码加密会话密钥(这就是解决速度问题的方法，因为对称密码的密钥一般比消息本身要短)</li>
<li>从混合密码系统外部赋予公钥密码加密时使用的密钥</li>
</ul>
<h4 id="4-2-混合密码系统的加密过程"><a href="#4-2-混合密码系统的加密过程" class="headerlink" title="4.2 混合密码系统的加密过程"></a>4.2 混合密码系统的加密过程</h4><p><img src="./images/图解密码技术总结/4.1.png" alt=""></p>
<h4 id="4-3-混合密码系统的解密过程"><a href="#4-3-混合密码系统的解密过程" class="headerlink" title="4.3 混合密码系统的解密过程"></a>4.3 混合密码系统的解密过程</h4><p><img src="./images/图解密码技术总结/4.2.png" alt=""></p>
<p>===<br>认证部分</p>
<p>===</p>
<h3 id="五-单向散列函数-—-获取消息的“指纹”"><a href="#五-单向散列函数-—-获取消息的“指纹”" class="headerlink" title="五. 单向散列函数 — 获取消息的“指纹”"></a>五. 单向散列函数 — 获取消息的“指纹”</h3><h4 id="5-1-什么是单向散列值（one-way-hash-function）"><a href="#5-1-什么是单向散列值（one-way-hash-function）" class="headerlink" title="5.1 什么是单向散列值（one-way hash function）"></a>5.1 什么是单向散列值（one-way hash function）</h4><ul>
<li>单向散列函数可以根据消息的内容计算出<strong>固定长度</strong>的散列值，用于验证消息的<strong>完整性</strong>。</li>
</ul>
<h4 id="5-2-单向散列函数的性质"><a href="#5-2-单向散列函数的性质" class="headerlink" title="5.2 单向散列函数的性质"></a>5.2 单向散列函数的性质</h4><ul>
<li>根据任意长度的消息计算出固定长度的散列值。</li>
<li>能够<strong>快速</strong>计算出散列值。</li>
<li>消息不同散列值不同。<ul>
<li><strong>弱</strong>抗碰撞性：要找到和该条消息具有相同散列值的另一条消息是非常困难的。</li>
<li><strong>强</strong>抗碰撞性：要找到散列值相同的两条不同的消息是非常困难的。</li>
</ul>
</li>
<li>具备单向性</li>
</ul>
<h4 id="5-3-单向散列函数的实际应用"><a href="#5-3-单向散列函数的实际应用" class="headerlink" title="5.3 单向散列函数的实际应用"></a>5.3 单向散列函数的实际应用</h4><ol>
<li><strong>检测软件是否被篡改</strong></li>
<li><strong>基于口令的加密</strong>（Password Based Encryption，PBE）：将口令和盐（salt，通过伪随机数生成器产生的随机值）混合后计算其散列值，然后将这个散列值用作加密的密钥。这样做可以防御针对口令的字典攻击。</li>
<li><strong>消息认证码</strong>：消息认证码是将“发送者和接受者之间的共享密钥”和“消息”进行混合计算出的散列值。使用消息认证码可以检测并防止通信过程中的错误、篡改以及伪装。</li>
<li><strong>数字签名</strong>：数字签名一般是通过单向散列函数计算出消息的散列值，然后在这个散列值上施加数字签名。</li>
<li><strong>伪随机数生成器</strong></li>
<li><strong>一次性口令</strong>：常被用于服务器对客户端的合法性认证。</li>
</ol>
<h4 id="5-4-单向散列函数的具体例子"><a href="#5-4-单向散列函数的具体例子" class="headerlink" title="5.4 单向散列函数的具体例子"></a>5.4 单向散列函数的具体例子</h4><ol>
<li>MD4、MD5</li>
<li>SHA-1、SHA-256、SHA-384、SHA-512</li>
<li>RIPEMD-160</li>
</ol>
<p>===</p>
<h3 id="六-消息认证码-—-消息被正确传送了吗"><a href="#六-消息认证码-—-消息被正确传送了吗" class="headerlink" title="六. 消息认证码 — 消息被正确传送了吗"></a>六. 消息认证码 — 消息被正确传送了吗</h3><h4 id="6-1-什么是消息认证码"><a href="#6-1-什么是消息认证码" class="headerlink" title="6.1 什么是消息认证码"></a>6.1 什么是消息认证码</h4><ul>
<li>消息认证码（message authentication code）是一种确认完整性并进行认证的技术，取三个单词的首字母，简称MAC。</li>
<li>消息认证码是输入包括任意长度的消息和一个发送者和接收者之间共享的密钥，它可以输出固定长度的数据，这个数据成为MAC值。</li>
<li>消息认证码是一种与密钥相关的单向散列函数。如下图</li>
</ul>
<p><img src="./images/图解密码技术总结/6.1.png" alt=""></p>
<h4 id="6-2-消息认证码的使用步骤图"><a href="#6-2-消息认证码的使用步骤图" class="headerlink" title="6.2 消息认证码的使用步骤图"></a>6.2 消息认证码的使用步骤图</h4><p><img src="./images/图解密码技术总结/6.2.png" alt=""></p>
<h4 id="6-3-消息认证码的密钥的配送问题"><a href="#6-3-消息认证码的密钥的配送问题" class="headerlink" title="6.3 消息认证码的密钥的配送问题"></a>6.3 消息认证码的密钥的配送问题</h4><p>看上图就知道，共享密钥的配送问题依旧存在。解决方法也和对称密码差不多，例如公钥密码，Diffie-Hellman密钥交换等，具体项目具体安排。</p>
<h4 id="6-4-消息认证码的应用实例"><a href="#6-4-消息认证码的应用实例" class="headerlink" title="6.4 消息认证码的应用实例"></a>6.4 消息认证码的应用实例</h4><ol>
<li>SWIFT</li>
<li>IPsec</li>
<li>SSL/TLS</li>
</ol>
<h4 id="6-5-对消息认证码的攻击"><a href="#6-5-对消息认证码的攻击" class="headerlink" title="6.5 对消息认证码的攻击"></a>6.5 对消息认证码的攻击</h4><ol>
<li>重放攻击</li>
<li>密钥推测攻击</li>
</ol>
<h4 id="6-6-消息认证码无法解决的问题"><a href="#6-6-消息认证码无法解决的问题" class="headerlink" title="6.6 消息认证码无法解决的问题"></a>6.6 消息认证码无法解决的问题</h4><ol>
<li>对第三方证明。第三方无法知道消息来自A,B哪一方。（数字签名可以证明）</li>
<li>防止否认。（数字签名可以防止否认）</li>
</ol>
<p>===</p>
<h3 id="七-数字签名-—-消息到底是谁写的"><a href="#七-数字签名-—-消息到底是谁写的" class="headerlink" title="七. 数字签名 — 消息到底是谁写的"></a>七. 数字签名 — 消息到底是谁写的</h3><ul>
<li>数字签名可以识别篡改和伪装，还可以防止否认。</li>
<li>数字签名可以看成是公钥密码的<strong>反用</strong>，如图</li>
</ul>
<p>公钥密码与数字签名的密钥使用方式<br><img src="./images/图解密码技术总结/7.1.png" alt=""> </p>
<p>公钥密码<br><img src="./images/图解密码技术总结/7.2.png" alt=""> </p>
<p>数字签名<br><img src="./images/图解密码技术总结/7.3.png" alt=""> </p>
<h4 id="7-1-数字签名的方法"><a href="#7-1-数字签名的方法" class="headerlink" title="7.1 数字签名的方法"></a>7.1 数字签名的方法</h4><ul>
<li>直接对消息签名的方法</li>
<li>对消息的散列值签名的方法（常用）</li>
</ul>
<h4 id="7-2-实际应用"><a href="#7-2-实际应用" class="headerlink" title="7.2 实际应用"></a>7.2 实际应用</h4><ol>
<li>安全信息公告：一些信息安全方面的组织会在其网站上发布一些安全漏洞的警告，那么如何验证这些警告信息真的是这个组织发布的呢？此时就可以用数字签名。</li>
<li>软件下载</li>
<li>公钥证书：用于验证公钥的合法性。</li>
<li>SSL/TLS</li>
</ol>
<h4 id="7-3-通过RSA实现数字签名"><a href="#7-3-通过RSA实现数字签名" class="headerlink" title="7.3 通过RSA实现数字签名"></a>7.3 通过RSA实现数字签名</h4><ul>
<li>签名 = 消息 D MOD N (消息的D次方除以N取余数)</li>
<li>由签名求得的消息 = 签名 E MOD N （签名的E次方除以N取余数）</li>
<li>D和N就是签名者的私钥</li>
<li>E和N就是签名者的公钥</li>
</ul>
<h4 id="7-4-对数字签名的攻击"><a href="#7-4-对数字签名的攻击" class="headerlink" title="7.4 对数字签名的攻击"></a>7.4 对数字签名的攻击</h4><ol>
<li>中间人攻击。（可以通过公钥证书来防止）</li>
<li>对单向散列函数的攻击</li>
<li>利用数字签名攻击公钥密码</li>
</ol>
<h4 id="7-5-各类密码技术的对比"><a href="#7-5-各类密码技术的对比" class="headerlink" title="7.5 各类密码技术的对比"></a>7.5 各类密码技术的对比</h4><p><img src="./images/图解密码技术总结/7.4.png" alt=""> </p>
<p>===</p>
<h3 id="八-证书-—-为公钥加上数字签名"><a href="#八-证书-—-为公钥加上数字签名" class="headerlink" title="八 证书 — 为公钥加上数字签名"></a>八 证书 — 为公钥加上数字签名</h3><h4 id="8-1-什么是证书"><a href="#8-1-什么是证书" class="headerlink" title="8.1 什么是证书"></a>8.1 什么是证书</h4><p>公钥证书（Public-Key Certificae，PKC）：里面记有姓名、组织、邮箱地址等个人信息，以及属于此人的<strong>公钥</strong>，并由<strong>认证机构</strong>（Certification Authority、Certifying Authority， CA）施加数字签名。只要看到公钥证书，我们就可以知道认证机构认定该公钥的确属于此人。公钥证书简称为证书（certificate）</p>
<h4 id="8-2-证书的应用场景"><a href="#8-2-证书的应用场景" class="headerlink" title="8.2 证书的应用场景"></a>8.2 证书的应用场景</h4><p><img src="./images/图解密码技术总结/8.1.png" alt=""> </p>
<h4 id="8-3-公钥基础设施（PKI）"><a href="#8-3-公钥基础设施（PKI）" class="headerlink" title="8.3 公钥基础设施（PKI）"></a>8.3 公钥基础设施（PKI）</h4><p>就是为了能够更有效的运用公钥而制定的一系列规范和规格的总称。</p>
<p>组成要素：</p>
<ul>
<li>用户 — 使用PKI的人</li>
<li>认证机构 — 颁发证书的人</li>
<li>仓库 — 保存证书的数据库</li>
</ul>
<p>===</p>
<h3 id="九-随机数-—-不可预测性的源泉"><a href="#九-随机数-—-不可预测性的源泉" class="headerlink" title="九 随机数 — 不可预测性的源泉"></a>九 随机数 — 不可预测性的源泉</h3><h4 id="9-1-随机数的性质"><a href="#9-1-随机数的性质" class="headerlink" title="9.1 随机数的性质"></a>9.1 随机数的性质</h4><ul>
<li>随机性 — 不存在统计学偏差，是完全杂乱的数列。（弱伪随机数）</li>
<li>不可预测性 — 不能从过去的数列推测出下一个出现的数。（强伪随机数）</li>
<li><p>不可重现性 — 除非将数列本身保存下来，否则不能重现相同的数列。（真随机数）</p>
<p>  上面三种性质中，越往下越严格。</p>
</li>
</ul>
<p><img src="./images/图解密码技术总结/9.1.png" alt=""> </p>
<ul>
<li>对于软件所生成的数列，周期必定是有限的。凡是有限周期的数列，都不具备不可重现性。</li>
<li>要生成不可重现的随机书里额，需要从不可重现的物理现象中获取信息。</li>
</ul>
<p>===</p>
<h3 id="十-SSL-TLS-—-为了更安全的通信"><a href="#十-SSL-TLS-—-为了更安全的通信" class="headerlink" title="十 SSL/TLS — 为了更安全的通信"></a>十 SSL/TLS — 为了更安全的通信</h3><h4 id="10-1-什么是SSL-TLS"><a href="#10-1-什么是SSL-TLS" class="headerlink" title="10.1 什么是SSL/TLS"></a>10.1 什么是SSL/TLS</h4><ul>
<li>是目前世界上最广泛的密码通信方法。</li>
<li>综合运用了前面提到的技术：对称密码、消息认证码、公钥密码、数字签名、伪随机数生成器等密码技术。</li>
</ul>
<p>===</p>
<h3 id="十一-密码技术与现实社会"><a href="#十一-密码技术与现实社会" class="headerlink" title="十一 密码技术与现实社会"></a>十一 密码技术与现实社会</h3><h4 id="11-1-密码学家的工具箱"><a href="#11-1-密码学家的工具箱" class="headerlink" title="11.1 密码学家的工具箱"></a>11.1 密码学家的工具箱</h4><p><img src="./images/图解密码技术总结/11.1.png" alt=""></p>
<h4 id="11-2-密码技术与压缩技术"><a href="#11-2-密码技术与压缩技术" class="headerlink" title="11.2 密码技术与压缩技术"></a>11.2 密码技术与压缩技术</h4><p><img src="./images/图解密码技术总结/11.2.png" alt=""></p>
<ul>
<li>密钥是机密性的精华</li>
<li>散列值是完整性的精华</li>
<li>认证符号（MAC值和签名）是认证的精华</li>
<li>种子是不可预测性的精华</li>
</ul>
<p><img src="./images/图解密码技术总结/11.3.png" alt=""></p>
<h4 id="11-3-只有完美的密码，没有完美的人"><a href="#11-3-只有完美的密码，没有完美的人" class="headerlink" title="11.3 只有完美的密码，没有完美的人"></a>11.3 只有完美的密码，没有完美的人</h4>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/04/不同unicode编码的空格挖的坑/" itemprop="url">
                  不同unicode编码的空格挖的坑
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-08-04T17:33:14+08:00" content="2016-08-04">
              2016-08-04
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/JS/" itemprop="url" rel="index">
                    <span itemprop="name">JS</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>前段时间在做搜索的时候，遇到一个关于空格的小问题，总结一下。</p>
<p>有时在文本值中会插入一些空格字符 （Unicode 字符集值 32 和 160） ，比如说标题之类的。当你对包含空格的值进行<strong>排序、 筛选或搜索</strong>时，这些字符有时会导致意外的结果。本次就是因为把数据存放在dom节点上，取出来做搜索的时候，发现编码发现了改变（从32变成了160），导致无法正确匹配。</p>
<blockquote>
<p>The non-breaking space (U+00A0 Unicode, 160 decimal, &nbsp;) is not the same as the space character (U+0020 Unicode, 32 decimal). Well, both of them seems to be a “space”, but they are absolutely different characters.</p>
</blockquote>
<p>这里的解决方案是：采用正则替换成统一字符，如下</p>
<pre><code>var s = &apos; &apos; // 假设这里是一个160的空格。
var reg = new RegExp(String.fromCharCode(160),&quot;gm&quot;);
var 32sp = String.fromCharCode(32)
s = s.replace(reg, 32sp);
</code></pre><p>后来重构代码，直接废除了将数据存在dom上这种方案，就更好了。</p>
<p>除了空格字符，非打印字符在进行<strong>排序、 筛选或搜索</strong>操作时，也可能会遇到这类问题，<a href="https://support.office.com/zh-cn/article/%E5%88%A0%E9%99%A4%E6%96%87%E6%9C%AC%E4%B8%AD%E7%9A%84%E7%A9%BA%E6%A0%BC%E5%92%8C%E9%9D%9E%E6%89%93%E5%8D%B0%E5%AD%97%E7%AC%A6-023f3a08-3d56-49e4-bf0c-fe5303222c9d" target="_blank" rel="external">参考</a>。要注意~</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="//schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/1.jpg"
               alt="黑月" />
          <p class="site-author-name" itemprop="name">黑月</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">13</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">19</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">黑月</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>

        

<div class="busuanzi-count">

  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv"><i class="fa fa-user"></i><span class="busuanzi-value" id="busuanzi_value_site_uv"></span></span>
  

  
    <span class="site-pv"><i class="fa fa-eye"></i><span class="busuanzi-value" id="busuanzi_value_site_pv"></span></span>
  
  
</div>



        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.2"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.2"></script>



  



  




  
  

  

  

  

  


</body>
</html>
